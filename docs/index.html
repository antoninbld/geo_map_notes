<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <title>Carte interactive</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- MapLibre -->
  <link href="https://unpkg.com/maplibre-gl@3.6.1/dist/maplibre-gl.css" rel="stylesheet" />
  <script src="https://unpkg.com/maplibre-gl@3.6.1/dist/maplibre-gl.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@turf/turf@6/turf.min.js"></script>

  <!-- Marked (pour le panneau interne Markdown) -->
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>

  <style>
    html, body { margin:0; padding:0; height:100%; }
    #map { width:100%; height:100%; }

    /* Panneau Map views + boutons recentrage (en haut √† gauche) */
    .basemap-control {
      position:absolute; top:10px; left:10px; z-index:10;
      background:#fff; border-radius:12px; padding:10px;
      box-shadow:0 4px 16px rgba(0,0,0,.15);
      font-family:system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      font-size:14px; width: 240px;
    }
    .basemap-control strong { display:block; margin-bottom:6px; }
    .basemap-control label { display:block; margin:6px 0; cursor:pointer; }
    .btn {
      display:inline-block; margin-top:6px; padding:8px 10px;
      background:#1e90ff; color:#fff; border:none; border-radius:8px;
      font-size:13px; cursor:pointer; width:100%; text-align:left;
      box-shadow:0 2px 8px rgba(30,144,255,.35);
    }
    .btn:hover { filter:brightness(.95); }

    /* Popup (carte) */
    .maplibregl-popup { max-width: 300px; font-family: system-ui, sans-serif; }
    .popup-title { font-size: 15px; font-weight: 600; margin-bottom: 4px; }
    .popup-meta  { font-size: 13px; color: #666; margin-bottom: 6px; }
    .popup-link  { display:inline-block; margin-top:6px; font-size:13px; color:#1e90ff; text-decoration:none; }
    .popup-link:hover { text-decoration: underline; }

    /* Bouton Filtres int√©gr√© au groupe de contr√¥les (en haut √† droite) */
    .maplibregl-ctrl.filters-ctrl .filters-btn{
      min-width:60px; height:30px; display:flex; align-items:center; justify-content:center;
      font-size:14px; background:#fff; border:none; cursor:pointer;
    }

    /* Panneau de filtres (pop-up) en haut √† droite */
    .filters-panel{
      position:absolute; top:115px; right:10px; z-index:10;
      width:360px; max-height:60vh; overflow:auto;
      background:#fff; border-radius:12px; padding:12px;
      box-shadow:0 8px 24px rgba(0,0,0,.18); font-family:system-ui, sans-serif; font-size:14px;
      display:none;
    }
    .s-panel h3{ margin:0 0 8px; font-size:16px; }
    .s-panel .row{ margin:8px 0; }
    .s-panel input[type="text"]{ width:100%; padding:8px; border:1px solid #ddd; border-radius:8px; }
    .s-panel .tags{ display:flex; flex-wrap:wrap; gap:6px; }
    .s-panel .tag{
      display:flex; align-items:center; gap:6px; padding:6px 8px; border:1px solid #e5e7eb; border-radius:8px;
    }
    .filters-actions{ display:flex; gap:8px; margin-top:10px; }
    .filters-actions button{
      flex:1; padding:8px; border:none; border-radius:8px; cursor:pointer;
    }
    .filters-apply{ background:#1e90ff; color:#fff; }
    .filters-reset{ background:#f3f4f6; }

    /* Panneau interne (lecture des notes) */
    .internal-link {
      text-decoration: none;
      border-bottom: 1px dashed #1e90ff;
    }
    .internal-link:hover { text-decoration: underline; }

    /* Liens internes style Obsidian (panel + r√©sum√©s) */
    .internal-link{ text-decoration:none; border-bottom:1px dashed #1e90ff; }

        :root { --recap-lines: 2; }
        /* R√©cap r√©duit sur N lignes (pilot√© par --recap-lines) */
        #npRecap.clamped {
          display: -webkit-box;
          -webkit-box-orient: vertical;
          -webkit-line-clamp: var(--recap-lines);
          overflow: hidden;
        }
    
        /* Lien de bascule [...] / ‚Ü• r√©duire */
        #npRecapToggle {
          cursor: pointer;
          display: inline-block;
          margin-top: 4px;
          text-decoration: underline;
          font-style: italic;
          user-select: none;
          font-size: 0.85em;   /* ‚Ü©Ô∏è taille relative au r√©cap */
          font-weight: normal; /* ‚Ü©Ô∏è plus l√©ger */
        }

  </style>
</head>
<body>
  <div id="map"></div>

  <!-- Panneau de lecture interne -->
  <div id="notePanel" style="position:absolute;right:10px;top:10px;width:400px;max-height:88vh;overflow:auto;background:#fff;border-radius:12px;box-shadow:0 8px 24px rgba(0,0,0,.18);padding:0;display:none;z-index:12;font-family:system-ui;">
    <!-- En-t√™te jaune -->
    <div id="npHeader" style="background:#facc15;padding:10px 12px;border-radius:12px 12px 0 0;border-bottom:1px solid #0f172a22; position:sticky; top:0; z-index:20;box-shadow:0 4px 8px rgba(0,0,0,.35);">
      <!-- Bouton croix en haut-droite -->
      <button id="npClose" type="button" aria-label="Fermer"
              style="position:absolute; top:8px; right:10px;
                     width:26px; height:26px;
                     display:flex; align-items:center; justify-content:center;
                     border:none; border-radius:6px;
                     background:#dc2626; color:#fff; cursor:pointer;
                     box-shadow:0 1px 4px rgba(0,0,0,.15);">
        ‚úñ
      </button>
      <div id="npTitle" style="font-size:16px;font-weight:700;">Titre</div>
    
      <!-- Lieu avec üìç -->
      <div id="npMeta" style="font-size:12px;opacity:.9;display:flex;align-items:center;gap:6px;margin-top:4px;">
        <span id="npIcon" style="font-size:14px;line-height:1">üìç</span>
        <span id="npPlace">Pays, ville</span>
      </div>
    
      <!-- Date SOUS la localisation -->
      <div id="npDate" style="font-size:12px;opacity:.8;margin-top:2px; margin-left:20px;">6 octobre 1981</div>
    
       <!-- Phrase r√©cap (optionnelle) -->
      <div id="npRecap" style="margin-top:6px; font-weight:600; font-style:italic;"></div>
      <a id="npRecapToggle" href="#" style="display:none;"></a>
    </div>


  
    <!-- Corps clair (marges homog√®nes) -->
    <div id="npWrapper" style="padding:6px 6px;">
      <div id="npCard" style="border:1px solid #0f172a22;border-radius:10px;padding:10px;background:#fef9c3;">
        <!-- Petite phrase avant la note (optionnelle) -->
        <div id="npSummary" style="font-size:14px;line-height:1.55;margin-bottom:8px;"></div>
        <!-- Markdown complet de la note -->
        <div id="npMd" style="font-size:14px;line-height:1.55;"></div>
      </div>
        
      <!-- Liens sortants -->
      <div id="npLinksWrap" style="margin-top:10px;">
        <div style="font-weight:700;margin:8px 0 6px;">Liens sortants</div>
        <div id="npLinks" style="font-size:14px;"></div>
        <div style="margin-top:8px;display:flex;gap:8px;">
          <button id="npFit"  type="button" style="padding:6px 8px;border:1px solid #e5e7eb;border-radius:6px;background:#fff;cursor:pointer;">üîé Voir les li√©s</button>
        </div>
      </div>
    </div>
    </div>

  <!-- Panneau Map Views + Recentrer -->
  <div class="basemap-control">
    <strong>Map views</strong>

    <!-- Fournisseur -->
    <strong style="display:block;margin-top:8px;">Fournisseur</strong>
    <label><input type="radio" name="provider" value="maptiler" checked> MapTiler</label>
    <label><input type="radio" name="provider" value="carto"> Carto</label>
    <!-- Projection -->
    <strong style="display:block;margin-top:8px;">Projection</strong>
    <label><input type="radio" name="projection" value="mercator" checked> 2D</label>
    <label><input type="radio" name="projection" value="globe"> 3D</label>
    
    <label><input type="radio" name="basemap" value="hybrid"> Satellite</label>
    <label><input type="radio" name="basemap" value="streets" checked> Streets</label>
    <label><input type="radio" name="basemap" value="light"> Light</label>
    <label><input type="radio" name="basemap" value="dark"> Dark</label>

    <button id="recenterEurope" class="btn" type="button">Recentrer Europe</button>
    <button id="recenterUSA" class="btn" type="button">Recentrer √âtats-Unis</button>
  </div>

  <!-- Panneau Filtres (pop-up) -->
  <div id="filtersPanel" class="filters-panel s-panel">
    <h3>Filtres</h3>

    <!-- Recherche -->
    <div class="row">
      <label>Recherche</label>
      <input type="text" id="filterQuery" placeholder="Titre, lieu, r√©sum√©‚Ä¶" />
    </div>

    <!-- Tags -->
    <div class="row">
      <label>Tags</label>
      <div id="tagsBox" class="tags"></div>
    </div>

    <!-- Pays -->
    <div class="row">
      <label>Pays</label>
      <select id="filterCountry" multiple size="6" style="width:100%; border:1px solid #ddd; border-radius:8px; padding:6px;">
        <!-- rempli dynamiquement -->
      </select>
      <div style="display:flex; gap:8px; margin-top:6px;">
        <button id="selectAllCountries"  class="filters-reset" type="button" style="flex:1;">Tout s√©lectionner</button>
        <button id="clearAllCountries"   class="filters-reset" type="button" style="flex:1;">Tout d√©s√©lectionner</button>
      </div>
    </div>

    <!-- Actions -->
    <div class="row">
      <div class="filters-actions">
        <button class="filters-apply" id="applyFilters" type="button">Appliquer</button>
        <button class="filters-reset" id="resetFilters" type="button">R√©initialiser</button>
      </div>
    </div>
  </div>

  <script>
    // üîë Mets ta cl√© MapTiler ici
    const MAPTILER_KEY = "MLrpRZ0Wo2Dsvsj13UYN"; // remplace si besoin


 
    const UI_CONFIG = {
    panel: {
      width: "400px",            // Largeur du panneau lat√©ral (ex: "400px" ou "30vw")
      marginRight: "10px",       // Espace entre le panneau et le bord droit de la carte
      marginTop: "10px",         // Espace entre le haut du panneau et la carte
      background: "#fff",        // Couleur de fond du panneau
      shadow: "0 8px 24px rgba(0,0,0,.18)", // Ombre port√©e (box-shadow)
      borderRadius: "12px"       // Arrondi des coins du panneau
    },
      
    header: {
      background: "#facc15",     // Couleur de fond du bandeau jaune (en-t√™te)
      textColor: "#000",         // Couleur du texte dans l‚Äôen-t√™te
      titleSize: "16px",         // Taille du titre (px)
      locationIcon: "üìç",        // Ic√¥ne affich√©e avant la localisation
      dateIndent: "20px",        // D√©calage gauche de la date (alignement sous la localisation)
      dateFormat: {              // Format de la date (Intl API)
        day: "numeric",
        month: "long",
        year: "numeric"
      },
      recapFontSize: "12px",
      recapStyle: "font-weight:600; font-style:italic;",        // Style appliqu√© √† la phrase r√©cap (gras, italique, couleur‚Ä¶)
      recapMaxLines: 2,                    // ‚Üê nombre de lignes visibles
      recapMoreLabel: " [‚Ä¶]",              // ‚Üê libell√© pour d√©ployer
      recapLessLabel: " ‚Ü• r√©duire"         // ‚Üê libell√© pour ¬´ retrousser ¬ª
    },
    
    card: {
      background: "#fef9c3",     // Couleur du bloc jaune clair (contenu)
      border: "1px solid #0f172a22", // Bordure autour du bloc jaune clair
      borderRadius: "10px",      // Arrondi du bloc jaune clair
      outerPadding: "8px 10px",  // Marge BLANCHE autour du bloc jaune clair (√©cart avec le panneau)
      innerPadding: "10px",      // Marge INTERNE du bloc jaune clair (espace texte ‚Üî bord du bloc)
      fontSize: "14px",          // Taille du texte dans la note
      lineHeight: "1.55"         // Interligne du texte
    },
    
    links: {
      sectionTitle: "Liens sortants", // Titre affich√© au-dessus de la liste des liens
      internalLinkColor: "#1e90ff",   // Couleur des liens internes [[...]]
      internalLinkUnderline: "dashed", // Style de soulignement des liens internes (dashed, solid, none)
      curveStyle: "geodesic",     // "bezier" | "geodesic"
      curveStrength: 0.25,      // B√©zier : 0.15 (l√©ger) √† 0.5 (prononc√©)
      curveSteps: 64            // nombre de points par courbe (qualit√© vs perf)

    },
    
    buttons: {
      fitText: "üîé Voir les li√©s", // Texte du bouton pour recadrer sur les notes li√©es
      closeText: "‚úñ Fermer",      // Texte du bouton pour fermer le panneau
      background: "#fff",         // Couleur de fond des boutons
      borderRadius: "6px"         // Arrondi des boutons
    }
  };



    // Cr√©e/actualise une balise <style> d√©di√©e aux overrides UI
    function setUIStyle(css){
      let tag = document.getElementById('ui-overrides');
      if (!tag) {
        tag = document.createElement('style');
        tag.id = 'ui-overrides';
        document.head.appendChild(tag);
      }
      tag.textContent = css;
    }
    
    // Applique le UI_CONFIG sur le panneau d√©j√† pr√©sent dans le DOM
    function applyUIConfig(){
      // Variables pratiques
      const P = UI_CONFIG.panel;
      const H = UI_CONFIG.header;
      const C = UI_CONFIG.card;
      const L = UI_CONFIG.links;
      const B = UI_CONFIG.buttons;
    
      // Styles dynamiques (CSS) pour classes/ids existants
      setUIStyle(`
        /* Panneau conteneur */
        #notePanel{
          width:${P.width};
          right:${P.marginRight};
          top:${P.marginTop};
          background:${P.background};
          box-shadow:${P.shadow};
          border-radius:${P.borderRadius};
        }
        /* En-t√™te */
        #npHeader{
          background:${H.background};
          color:${H.textColor};
        }
        #npTitle{ font-size:${H.titleSize}; }
        #npDate{ margin-left:${H.dateIndent}; }
        #npRecap{ ${H.recapStyle}; font-size:${H.recapFontSize || "13px"}; width:100%; text-align:justify; }
    
        /* Bloc contenu */
        #npWrapper{ padding:${C.outerPadding}; }
        #npCard{
          background:${C.background};
          border:${C.border};
          border-radius:${C.borderRadius};
          padding:${C.innerPadding};
          font-size:${C.fontSize};
          line-height:${C.lineHeight};
        }
    
        /* Liens internes */
        .internal-link{
          text-decoration: none;
          border-bottom: 1px ${L.internalLinkUnderline} ${L.internalLinkColor};
          color: inherit;
        }
        .internal-link:hover{ text-decoration: underline; }
    
        /* Boutons */
        #npLinksWrap button{
          background:${B.background};
          border-radius:${B.borderRadius};
        }
      `);
    
      // Texte/icone dynamiques
      const icon = document.getElementById('npIcon');
      if (icon) icon.textContent = H.locationIcon;
    
      // Titres/labels dynamiques
      const linksTitle = document.querySelector('#npLinksWrap > div:first-child');
      if (linksTitle) linksTitle.textContent = L.sectionTitle;
    
      const btnFit  = document.getElementById('npFit');
      if (btnFit) btnFit.textContent = B.fitText;
      // Pas de texte pour la croix : on laisse le symbole ‚úñ dans le HTML du header

      // Propager le nombre de lignes vers le CSS (line-clamp)
      document.documentElement.style.setProperty('--recap-lines', String((UI_CONFIG.header && UI_CONFIG.header.recapMaxLines) || 2));
      
    }

    // Utilitaire: debounce simple
    function debounce(fn, wait=120){ let t; return (...a)=>{ clearTimeout(t); t=setTimeout(()=>fn(...a), wait); }; }
    
    // Utilitaire: convertir HTML -> texte brut (pour ne pas couper au milieu d'une balise)
    function htmlToText(html){
      const d = document.createElement('div');
      d.innerHTML = html;
      return d.textContent || d.innerText || '';
    }

    // Renvoie une hauteur de ligne en pixels (g√®re le cas 'normal')
    function resolveLineHeight(el){
      const cs = getComputedStyle(el);
      const lh = cs.lineHeight;
      if (!lh || lh === 'normal') {
        const fs = parseFloat(cs.fontSize) || 14;
        return Math.round(fs * 1.33); // approximation standard du 'normal'
      }
      const n = parseFloat(lh);
      return isNaN(n) ? 18 : n;
    }
    
    // Tronque #npRecap √† N lignes, ajoute [...] / ‚Ü• r√©duire, sans couper de mot.
    // Mesure robuste via un conteneur invisible √† largeur fixe.
    function clampRecap(maxLines){
      const wrap = document.getElementById('npRecap');
      if (!wrap) return;
    
      const width = wrap.clientWidth || wrap.getBoundingClientRect().width || 0;
      if (width <= 0) {
        requestAnimationFrame(() => clampRecap(maxLines));
        return;
      }
    
      const H = UI_CONFIG.header;
      const moreLabel = H.recapMoreLabel || ' [‚Ä¶]';
      const lessLabel = H.recapLessLabel || ' ‚Ü• r√©duire';
      const lines = maxLines || 2;

    
      // HTML complet d√©j√† inject√© par openSummaryInPanel (on le garde pour l'√©tat "√©tendu")
      const fullHtml = wrap.innerHTML.trim();
      if (!fullHtml){
        wrap.innerHTML = '';
        return;
      }
    
      // Texte brut (pour tronquer proprement au mot)
      const tmp = document.createElement('div');
      tmp.innerHTML = fullHtml;
      const fullText = (tmp.textContent || tmp.innerText || '').trim();
    
      // ----- Mesureur invisible √† largeur fixe -----
      // On copie les styles de wrap pour une mesure fid√®le
      const cs = getComputedStyle(wrap);
      const meas = document.createElement('div');
      meas.style.position = 'absolute';
      meas.style.left = '-9999px';
      meas.style.top = '-9999px';
      meas.style.visibility = 'hidden';
      meas.style.whiteSpace = 'normal';
      meas.style.wordBreak = 'break-word';
      meas.style.width = wrap.clientWidth + 'px';
      meas.style.fontSize = cs.fontSize;
      meas.style.lineHeight = (cs.lineHeight === 'normal')
        ? (parseFloat(cs.fontSize || '14') * 1.33) + 'px'
        : cs.lineHeight;
      meas.style.fontFamily = cs.fontFamily;
      meas.style.fontWeight = cs.fontWeight;
      meas.style.fontStyle  = cs.fontStyle;
      meas.style.letterSpacing = cs.letterSpacing;
      document.body.appendChild(meas);
    
      const lineH = parseFloat(meas.style.lineHeight) || 18;
      const maxH  = Math.ceil(lineH * lines);
    
      // Fonction de mesure
      const heightFor = (text) => {
        meas.textContent = text;
        return meas.scrollHeight;
      };
    
      // Si tout tient d√©j√† en <= N lignes ‚Üí pas de bouton
      if (heightFor(fullText) <= maxH + 1){
        wrap.innerHTML = fullHtml;
        document.body.removeChild(meas);
        return;
      }
    
      // ----- Construire l‚ÄôUI (span + toggle) -----
      wrap.innerHTML = '';
      const span = document.createElement('span');
      span.id = 'npRecapText';
      span.style.display = 'block';
      span.style.width = '100%';
      span.style.whiteSpace = 'normal';
      span.style.wordBreak = 'break-word';
    
      const toggle = document.createElement('a');
      toggle.id = 'npRecapToggle';
      toggle.className = 'np-recap-toggle';
      toggle.href = '#';
      toggle.style.marginLeft = '2px';
    
      wrap.appendChild(span);
      wrap.appendChild(toggle);
    
      // ----- Recherche dichotomique au mot pr√®s -----
      const words = fullText.split(/\s+/);
      let lo = 0, hi = words.length, best = 0;
      while (lo <= hi){
        const mid = (lo + hi) >> 1;
        const probe = words.slice(0, mid).join(' ').trim();
        if (heightFor(probe) <= maxH + 1){ best = mid; lo = mid + 1; }
        else { hi = mid - 1; }
      }
      let truncated = words.slice(0, best).join(' ').trim();
    
      // Appliquer l‚Äô√©tat r√©duit
      let expanded = false;
      const setExpanded = (on) => {
        expanded = on;
        if (expanded){
          span.innerHTML = fullHtml;   // on remet l‚ÄôHTML complet (gras/italique conserv√©s)
          toggle.textContent = lessLabel;
        } else {
          span.textContent = truncated;
          toggle.textContent = moreLabel;
        }
      };
      setExpanded(false);
    
      toggle.addEventListener('click', (e) => {
        e.preventDefault();
        setExpanded(!expanded);
      });
    
      // Recalibrer si la largeur change (quand repli√©)
      const onResize = (() => {
        let t; return () => {
          clearTimeout(t); t = setTimeout(() => {
            if (expanded) return;
            // Recalcule la largeur du mesureur + tronquage
            meas.style.width = wrap.clientWidth + 'px';
            lo = 0; hi = words.length; best = 0;
            while (lo <= hi){
              const mid = (lo + hi) >> 1;
              const probe = words.slice(0, mid).join(' ').trim();
              if (heightFor(probe) <= maxH + 1){ best = mid; lo = mid + 1; }
              else { hi = mid - 1; }
            }
            truncated = words.slice(0, best).join(' ').trim();
            setExpanded(false);
          }, 160);
        };
      })();
      window.addEventListener('resize', onResize);
    
      // Nettoyage du mesureur (on le garde si on veut recalculer ‚Üí ici on le retire)
      document.body.removeChild(meas);
    }


    // Styles MapTiler (vector)
    const STYLES = {
      hybrid: `https://api.maptiler.com/maps/hybrid/style.json?key=${MAPTILER_KEY}`,
      streets:`https://api.maptiler.com/maps/streets/style.json?key=${MAPTILER_KEY}`,
      light:  `https://api.maptiler.com/maps/basic/style.json?key=${MAPTILER_KEY}`,
      dark:   `https://api.maptiler.com/maps/dataviz-dark/style.json?key=${MAPTILER_KEY}`
    };

    // Provider & style courants
    let CURRENT_PROVIDER = 'maptiler';   // 'maptiler' | 'carto'
    let CURRENT_BASEMAP  = 'streets';    // 'hybrid' | 'streets' | 'light' | 'dark'
    let CURRENT_PROJECTION = 'mercator'; // 'mercator' | 'globe'
    
    // R√©sout l'URL du style selon provider + basemap
    function getStyleURL(provider, basemap){
      if (provider === 'carto') {
        // Carto: mapping simple de nos 4 choix
        const cartoId = ({
          streets: 'voyager',
          light:   'positron',
          dark:    'dark-matter',
          hybrid:  'voyager' // pas de satellite chez Carto ‚Üí fallback
        })[basemap] || 'voyager';
        return `https://basemaps.cartocdn.com/gl/${cartoId}-gl-style/style.json`;
      }
      // MapTiler par d√©faut
      return STYLES[basemap] || STYLES.streets;
    }

    function applyProjection() {
      try {
        map.setProjection(CURRENT_PROJECTION);
        if (CURRENT_PROJECTION === 'globe') {
          map.setFog({
            range: [0.5, 10],
            color: 'rgba(200, 210, 230, 0.6)',
            'horizon-blend': 0.2
          });
          // Si on est tr√®s zoom√©, d√©zoome un peu pour bien voir la sph√®re
          if (map.getZoom() > 2) {
          }
        } else {
          map.setFog(null);
        }
      } catch (err) {
        console.warn('Projection non support√©e:', err);
      }
    }
    
    // === Liens fa√ßon Obsidian entre notes (globals) ===
    const NOTE_RAW_BASE = 'https://raw.githubusercontent.com/antoninbld/geo_map_notes/main/docs/notes';
    const idToItem = new Map();     // id -> item (depuis data.json)
    const linksCache = new Map();   // id -> [linkedId, ...]
    let linksSourceReady = false;   // source/layer pour les traits
    window.__lastLinksState = null; // dernier √©tat dessin√©

    // üéØ Vues par d√©faut
    const DEFAULT_ZOOM   = 3.8;
    const EUROPE_CENTER  = [10, 50];
    const USA_CENTER     = [-98.5, 39.8];

    // Carte
    const map = new maplibregl.Map({
      container: 'map',
      style: getStyleURL(CURRENT_PROVIDER, CURRENT_BASEMAP),
      center: EUROPE_CENTER,
      zoom:   DEFAULT_ZOOM,
      projection: 'mercator' // 2D par d√©faut ; on togglera en live
    });
    // R√©applique la projection (2D/3D) √† CHAQUE changement de style
    map.on('styledata', () => {
      applyProjection();
    });

    // (debug utile)
    map.on('error', (e) => console.error('Map error:', e && (e.error || e)));

    // Contr√¥les zoom (en haut √† droite)
    map.addControl(new maplibregl.NavigationControl({ showCompass: false }), 'top-right');

    // Bouton "Filtres" √† c√¥t√© du +/-
    class FilterControl {
      onAdd(map){
        this._map = map;
        const group = document.createElement('div');
        group.className = 'maplibregl-ctrl maplibregl-ctrl-group filters-ctrl';

        const btn = document.createElement('button');
        btn.className = 'filters-btn';
        btn.type = 'button';
        btn.title = 'Filtres';
        btn.textContent = 'Filtres';
        btn.addEventListener('click', () => {
          const panel = document.getElementById('filtersPanel');
          panel.style.display = panel.style.display === 'none' || !panel.style.display ? 'block' : 'none';
        });

        // Ferme le panneau filtres si on clique ailleurs
        document.addEventListener('click', (e) => {
          const panel = document.getElementById('filtersPanel');
          const btn = document.querySelector('.filters-btn');
          if (!panel || !btn) return;
          if (panel.style.display === 'block' && !panel.contains(e.target) && !btn.contains(e.target)) {
            panel.style.display = 'none';
          }
        });

        group.appendChild(btn);
        this._container = group;
        return group;
      }
      onRemove(){ this._container.remove(); this._map = undefined; }
    }
    map.addControl(new FilterControl(), 'top-right');

    // Labels visibles apr√®s changement de style
    function setLabelVisibility(visible) {
      const style = map.getStyle();
      if (!style || !style.layers) return;
      style.layers.forEach(layer => {
        const isText = layer.type === 'symbol' && layer.layout && layer.layout['text-field'];
        const looksLikeLabel = /label|place|country|state|city|town|village/i.test(layer.id);
        if (isText || looksLikeLabel) {
          try { map.setLayoutProperty(layer.id, 'visibility', visible ? 'visible' : 'none'); } catch {}
        }
      });
    }

    // === Pays: bbox & helpers ===
    let countriesBbox = {}; // nom -> [minLon, minLat, maxLon, maxLat]

    async function loadCountries(){
      try{
        const res = await fetch('countries-bbox.json', { cache: 'no-store' });
        countriesBbox = await res.json();
        buildCountrySelect();
      }catch(e){
        console.error('Erreur chargement countries-bbox.json', e);
      }
    }

    function buildCountrySelect(){
      const sel = document.getElementById('filterCountry');
      if (!sel) return;
      sel.innerHTML = '';
      Object.keys(countriesBbox).sort((a,b)=>a.localeCompare(b)).forEach(name => {
        const opt = document.createElement('option');
        opt.value = name;
        opt.textContent = name;
        sel.appendChild(opt);
      });
    }

    // Permet de cocher/d√©cocher les pays par simple clic (sans Ctrl/‚åò)
    const countrySel = document.getElementById('filterCountry');
    if (countrySel) {
      countrySel.addEventListener('mousedown', (e) => {
        const opt = e.target;
        if (opt.tagName === 'OPTION') {
          e.preventDefault();            // √©vite la s√©lection exclusive
          opt.selected = !opt.selected;  // toggle
          countrySel.dispatchEvent(new Event('change', { bubbles: true }));
        }
      });
    }

    function pointInBbox(lon, lat, bbox){
      const [minX, minY, maxX, maxY] = bbox;
      return lon >= minX && lon <= maxX && lat >= minY && lat <= maxY;
    }

    // Recentrages
    function recenterEurope() {
      map.easeTo({ center: EUROPE_CENTER, zoom: DEFAULT_ZOOM, duration: 600 });
    }
    function recenterUSA() {
      map.easeTo({ center: USA_CENTER, zoom: DEFAULT_ZOOM, duration: 600 });
    }
    document.getElementById('recenterEurope').addEventListener('click', recenterEurope);
    document.getElementById('recenterUSA').addEventListener('click', recenterUSA);

    // Raccourcis clavier : E (Europe), U (USA)
    window.addEventListener('keydown', (e) => {
      const key = e.key.toLowerCase();
      if (key === 'e') recenterEurope();
      if (key === 'u') recenterUSA();
    });

    // Changement de fond (robuste pour recr√©er la couche liens)
    document.querySelectorAll('input[name="basemap"]').forEach(radio => {
      radio.addEventListener('change', (e) => {
        const choice = e.target.value;          // 'hybrid' | 'streets' | 'light' | 'dark'
        CURRENT_BASEMAP = choice;
        map.setStyle(getStyleURL(CURRENT_PROVIDER, CURRENT_BASEMAP));
    
        const rebuild = () => {
          applyProjection(); // ‚Üê re-applique 2D/3D + fog
          addMarkersFromJSON().then(applyFilters);
          linksSourceReady = false;
          ensureLinksLayer();
          if (window.__lastLinksState) {
            const { id, links } = window.__lastLinksState;
            drawLinksFrom(id, links);
          }
        };
        map.once('load', rebuild);
        map.once('styledata', rebuild);
      });
    });
    
    // Fournisseur (MapTiler / Carto)
    document.querySelectorAll('input[name="provider"]').forEach(radio => {
      radio.addEventListener('change', (e) => {
        CURRENT_PROVIDER = e.target.value;  // 'maptiler' | 'carto'
        map.setStyle(getStyleURL(CURRENT_PROVIDER, CURRENT_BASEMAP));
    
        const rebuild = () => {
          applyProjection(); // ‚Üê re-applique 2D/3D + fog
          addMarkersFromJSON().then(applyFilters);
          linksSourceReady = false;
          ensureLinksLayer();
          if (window.__lastLinksState) {
            const { id, links } = window.__lastLinksState;
            drawLinksFrom(id, links);
          }
        };
        map.once('load', rebuild);
        map.once('styledata', rebuild);
    
        refreshBasemapOptionsForProvider();
      });
    });
    
    function refreshBasemapOptionsForProvider(){
      const sat = document.querySelector('input[name="basemap"][value="hybrid"]');
      if (!sat) return;
      const isCarto = CURRENT_PROVIDER === 'carto';
      sat.disabled = isCarto;
      if (isCarto && sat.checked) {
        const streets = document.querySelector('input[name="basemap"][value="streets"]');
        if (streets) { streets.checked = true; streets.dispatchEvent(new Event('change', { bubbles:true })); }
      }
    }
    window.addEventListener('load', refreshBasemapOptionsForProvider);
    window.addEventListener('load', () => {
      const r = document.querySelector('input[name="projection"]:checked');
      CURRENT_PROJECTION = r ? r.value : 'mercator';
      applyProjection();
    });
    
    // Projection (2D / 3D)
    document.querySelectorAll('input[name="projection"]').forEach(radio => {
      radio.addEventListener('change', (e) => {
       // ‚¨á‚¨á remplace tout l'int√©rieur par ceci
      const proj = e.target.value;           // 'mercator' | 'globe'
      CURRENT_PROJECTION = proj;
      applyProjection();
    });
  }); 
      
    // === Helpers Obsidian/panneau ===
    function parseAndStripFrontMatter(text){
      let meta = {};
      if (text.startsWith('---')) {
        const end = text.indexOf('\n---', 3);
        if (end !== -1) {
          const fm = text.slice(3, end).trim();
          text = text.slice(end + 4).trimStart();
          fm.split('\n').forEach(line => {
            const idx = line.indexOf(':');
            if (idx > -1) {
              const key = line.slice(0, idx).trim();
              let val = line.slice(idx + 1).trim();
              if ((val.startsWith('"') && val.endsWith('"')) || (val.startsWith("'") && val.endsWith("'"))) {
                val = val.slice(1, -1);
              }
              meta[key] = val;
            }
          });
        }
      }
      return { meta, body: text };
    }

    function transformWikiLinks(md){
      return md.replace(/\[\[([^\]\|]+)(?:\|([^\]]+))?\]\]/g, (m, rawId, label) => {
        const id = String(rawId||'').trim();
        if (!id) return m;
        const txt = String(label||id).trim();
        return `[${txt}](note.html?id=${encodeURIComponent(id)})`;
      });
    }

    // === R√©cap: gestion via CSS (clamp) + toggle ===================================
    function updateRecapToggleLabel(collapsed) {
      const t = document.getElementById('npRecapToggle');
      if (!t) return;
      const H = (window.UI_CONFIG && UI_CONFIG.header) || {};
      t.textContent = collapsed ? (H.recapMoreLabel || ' [‚Ä¶]') : (H.recapLessLabel || ' ‚Ü• r√©duire');
    }

    function setupRecapToggle() {
      const wrap = document.getElementById('npRecap');
      const t = document.getElementById('npRecapToggle');
      if (!wrap || !t) return;

      const hasText = !!wrap.textContent.trim();
      t.style.display = hasText ? 'inline-block' : 'none';
      if (!hasText) return;

      // √âtat initial: r√©duit
      wrap.classList.add('clamped');
      updateRecapToggleLabel(true);

      t.onclick = (e) => {
        e.preventDefault();
        const collapsed = wrap.classList.toggle('clamped'); // true si r√©duit apr√®s toggle
        updateRecapToggleLabel(collapsed);
      };
    }

    function setRecapText(text) {
      const wrap = document.getElementById('npRecap');
      if (!wrap) return;
      // On rend les [[liens]] cliquables dans le r√©cap
      wrap.innerHTML = text ? renderWikiLinksInline(text) : '';
      setupRecapToggle();
    }

    async function openNoteInPanel(noteId){
      try{
        const url = `${NOTE_RAW_BASE}/${encodeURIComponent(noteId)}.md`;
        const res = await fetch(url, { cache:'no-store' });
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        const md = await res.text();
        const { meta, body } = parseAndStripFrontMatter(md);
        const html = marked.parse(transformWikiLinks(body));

        document.getElementById('npTitle').textContent =
          (meta.title && meta.title.trim()) || (idToItem.get(noteId)?.title || noteId);
        const $npBody = document.getElementById('npMd');
        $npBody.innerHTML = html;
        document.getElementById('notePanel').style.display = 'block';

        // Interception des liens internes du panneau
        $npBody.querySelectorAll('a[href^="note.html?id="]').forEach(a => {
          a.classList.add('internal-link');
          a.addEventListener('click', (e) => {
            e.preventDefault();
            const href = a.getAttribute('href');
            const id = decodeURIComponent(href.split('id=')[1] || '');
            if (!id) return;

            openNoteInPanel(id);

            getOutgoingLinks(id).then(links => {
              drawLinksFrom(id, links);
              window.__lastLinksState = { id, links };
              const b = new maplibregl.LngLatBounds();
              const from = idToItem.get(id); if (from) b.extend([from.lon, from.lat]);
              links.forEach(l => { const t = idToItem.get(l); if (t) b.extend([t.lon, t.lat]); });
              if (!b.isEmpty()) map.fitBounds(b, { padding: 80, duration: 650 });
            });
          });
        });
      }catch(err){
        document.getElementById('npTitle').textContent = noteId;
        document.getElementById('npBody').innerHTML = `<em style="color:#b91c1c;">Note introuvable (${err.message})</em>`;
        document.getElementById('notePanel').style.display = 'block';
      }
    }
    // rendre accessible globalement si besoin
    window.openNoteInPanel = openNoteInPanel;

    // Parse robuste : "YYYY-MM-DD", "DD/MM/YYYY", "DD-MM-YYYY" -> Date  
    function parseDateSmart(s){
      if (!s) return null;
      const str = String(s).trim();
      let m = str.match(/^(\d{4})-(\d{2})-(\d{2})$/);           // YYYY-MM-DD
      if (m) return new Date(+m[1], +m[2]-1, +m[3]);
      m = str.match(/^(\d{2})\/(\d{2})\/(\d{4})$/);             // DD/MM/YYYY
      if (m) return new Date(+m[3], +m[2]-1, +m[1]);
      m = str.match(/^(\d{2})-(\d{2})-(\d{4})$/);               // DD-MM-YYYY
      if (m) return new Date(+m[3], +m[2]-1, +m[1]);
      return null;
    }
    function formatDateByConfig(s){
      const d = parseDateSmart(s);
      if (!d) return s || '';
      return new Intl.DateTimeFormat('fr-FR', UI_CONFIG.header.dateFormat).format(d);
    }



  // Ouvre le R√âCAP + la NOTE COMPL√àTE dans le panneau (avec clamp du r√©cap)
  async function openSummaryInPanel(noteId){
    const item   = idToItem.get(noteId);
    const $panel = document.getElementById('notePanel');
    const $title = document.getElementById('npTitle');
    const $place = document.getElementById('npPlace');
    const $date  = document.getElementById('npDate');
    const $recap = document.getElementById('npRecap');
    const $sum   = document.getElementById('npSummary');
    const $md    = document.getElementById('npMd');
    const $links = document.getElementById('npLinks');
    const $fit   = document.getElementById('npFit');
  
    // S√©curit√©
    if (!item) {
      $title.textContent = noteId;
      $place.textContent = '';
      $date.textContent  = '';
      $recap.innerHTML   = '';
      $sum.innerHTML     = '';
      $md.innerHTML      = '';
      $links.innerHTML   = '';
      $panel.style.display = 'block';
      return;
    }
  
    // ---- En-t√™te : titre + üìç lieu (date sera remplie depuis .md)
    $title.textContent = item.title || noteId;
    $place.textContent = item.locationName || '';
    $date.textContent  = '';
  
    // ---- R√©cap (phrase courte) : d‚Äôabord data.json, puis √©ventuellement .md
    setRecapText(item.recap || '');
  
    // ---- Petit ‚Äúsummary‚Äù avant la note (facultatif)
    $sum.innerHTML = item.summary ? renderWikiLinksInline(item.summary) : '';
  
    // ---- NOTE COMPL√àTE (lecture .md) + date + recap (fallback)
    let links = [];
    try {
      const url = `${NOTE_RAW_BASE}/${encodeURIComponent(noteId)}.md`;
      const res = await fetch(url, { cache:'no-store' });
      if (res.ok) {
        const mdRaw = await res.text();
        const { meta, body } = parseAndStripFrontMatter(mdRaw);
  
        // date (front-matter)
        if (!$date.textContent && meta.date) {
          $date.textContent = formatDateByConfig(meta.date);
        }
        // recap depuis le .md si pas donn√© dans data.json
        if (!document.getElementById('npRecap').innerHTML && meta.recap) {
          setRecapText(meta.recap);
        }

  
        // Liens sortants (ids pr√©sents en [[...]])
        links = extractWikiLinks(mdRaw).filter(id => idToItem.has(id));
  
        // Rendu HTML de la note
        const htmlNote = marked.parse(transformWikiLinks(body));
        $md.innerHTML = htmlNote;
      } else {
        $md.innerHTML = `<em style="color:#888;">Note compl√®te indisponible (HTTP ${res.status})</em>`;
      }
    } catch (err) {
      $md.innerHTML = `<em style="color:#888;">Note compl√®te indisponible</em>`;
    }
  
    // ---- Section "Liens sortants"
    if (!links.length) {
      $links.innerHTML = `<div style="color:#888;">Aucun lien sortant</div>`;
    } else {
      $links.innerHTML = `
        <ul style="margin:0; padding-left:18px;">
          ${links.map(lid => {
            const it = idToItem.get(lid);
            const lbl = it?.title || lid;
            const commonTags = Array.isArray(item.tags) && Array.isArray(it?.tags)
              ? item.tags.filter(t => it.tags.includes(t))
              : [];
            const badge = commonTags.length
              ? ` <span style="color:#6b7280;">(${commonTags.join(', ')})</span>`
              : '';
            return `<li><a href="note.html?id=${encodeURIComponent(lid)}" class="internal-link">${lbl}</a>${badge}</li>`;
          }).join('')}
        </ul>
      `;
    }
  
    // ---- Affichage panneau
    $panel.style.display = 'block';
  
    // ---- Navigation interne dans le panneau
    $panel.querySelectorAll('a[href^="note.html?id="]').forEach(a => {
      a.classList.add('internal-link');
      a.addEventListener('click', (e) => {
        e.preventDefault();
        const href = a.getAttribute('href');
        const id = decodeURIComponent(href.split('id=')[1] || '');
        if (!id) return;
        openSummaryInPanel(id);
        getOutgoingLinks(id).then(lnk => {
          drawLinksFrom(id, lnk);
          window.__lastLinksState = { id, links: lnk };
          const b = new maplibregl.LngLatBounds();
          const from = idToItem.get(id); if (from) b.extend([from.lon, from.lat]);
          lnk.forEach(L => { const t = idToItem.get(L); if (t) b.extend([t.lon, t.lat]); });
          if (!b.isEmpty()) map.fitBounds(b, { padding: 80, duration: 650 });
        });
      });
    });
  
    // ---- Bouton ‚ÄúVoir les li√©s‚Äù
    if ($fit) {
      $fit.onclick = () => {
        const b = new maplibregl.LngLatBounds();
        const from = idToItem.get(noteId); if (from) b.extend([from.lon, from.lat]);
        links.forEach(lid => { const t = idToItem.get(lid); if (t) b.extend([t.lon, t.lat]); });
        if (!b.isEmpty()) map.fitBounds(b, { padding: 80, duration: 650 });
      };
    }
  
    // ---- Traits & √©tat m√©moris√©
    drawLinksFrom(noteId, links);
    window.__lastLinksState = { id: noteId, links };
  }




    // --- [[...]] cliquables dans les r√©sum√©s (summary de data.json) ---
    function renderWikiLinksInline(text){
      if (!text) return '';
      return text.replace(/\[\[([^\]\|]+)(?:\|([^\]]+))?\]\]/g, (m, rawId, label) => {
        const id = String(rawId).trim();
        const txt = (label || id).trim();
        return `<a href="note.html?id=${encodeURIComponent(id)}" target="_blank" rel="noopener" class="internal-link">${txt}</a>`;
      });
    }

    // === Liens fa√ßon Obsidian entre notes ===
    function extractWikiLinks(mdText){
      const found = new Set();
      const re = /\[\[([^\]\|]+)(?:\|[^\]]+)?\]\]/g;
      let m;
      while ((m = re.exec(mdText)) !== null) {
        const id = m[1].trim();
        if (id) found.add(id);
      }
      return Array.from(found);
    }

    async function getOutgoingLinks(noteId){
      if (linksCache.has(noteId)) return linksCache.get(noteId);
      const url = `${NOTE_RAW_BASE}/${encodeURIComponent(noteId)}.md`;
      const res = await fetch(url, { cache:'no-store' });
      if (!res.ok) { linksCache.set(noteId, []); return []; }
      const md = await res.text();
      const ids = extractWikiLinks(md).filter(id => idToItem.has(id));
      linksCache.set(noteId, ids);
      return ids;
    }

    function ensureLinksLayer(){
      const LINK_COLOR = '#8c0503';
      const add = () => {
        // Source si absente
        if (!map.getSource('note-links')) {
          map.addSource('note-links', { type: 'geojson', data: { type:'FeatureCollection', features:[] } });
        }
    
        // 1) Casing (halo) ‚Äî en dessous
        if (!map.getLayer('note-links-casing')) {
          map.addLayer({
            id: 'note-links-casing',
            type: 'line',
            source: 'note-links',
            layout: {
              'line-cap': 'round',
              'line-join': 'round'
            },
            paint: {
              // blanc cass√© l√©g√®rement transparent
              'line-color': '#ffffff',
              'line-opacity': 0.65,
              // largeur adaptative au zoom
              'line-width': [
                'interpolate', ['linear'], ['zoom'],
                3, 2.0,   // zoom 3 ‚Üí 2px
                6, 3.0,   // zoom 6 ‚Üí 3px
                10, 4.0   // zoom 10 ‚Üí 4px
              ],
              'line-blur': 0.2
            }
          });
        }
    
        // 2) Trait principal ‚Äî au-dessus
        if (!map.getLayer('note-links-line')) {
          map.addLayer({
            id: 'note-links-line',
            type: 'line',
            source: 'note-links',
            layout: {
              'line-cap': 'round',
              'line-join': 'round'
            },
            paint: {
              // bleu ‚Äúliens‚Äù
              'line-color': LINK_COLOR,
              'line-opacity': 0.9,
              'line-width': [
                'interpolate', ['linear'], ['zoom'],
                3, 1.0,
                6, 1.5,
                10, 2.0
              ]
            }
          });
        }
    
        // 3) (Optionnel) Fl√®ches directionnelles
        if (!map.hasImage('arrow-head')) {
          // petit triangle vers la droite
          const size = 32, c = document.createElement('canvas');
          c.width = size; c.height = size;
          const ctx = c.getContext('2d');
          ctx.fillStyle = LINK_COLOR;
          ctx.beginPath();
          ctx.moveTo(26, 16); ctx.lineTo(8, 6); ctx.lineTo(8, 26); ctx.closePath();
          ctx.fill();
          map.addImage('arrow-head', c, { pixelRatio: 2 });
        }
        if (!map.getLayer('note-links-arrows')) {
          map.addLayer({
            id: 'note-links-arrows',
            type: 'symbol',
            source: 'note-links',
            layout: {
              'symbol-placement': 'line',
              'symbol-spacing': 80,          // distance entre fl√®ches
              'icon-image': 'arrow-head',
              'icon-size': 0.35,             // taille des fl√®ches
              'icon-rotation-alignment': 'map',
              'icon-allow-overlap': true
            },
            paint: {
              'icon-opacity': 0.85
            }
          });
        }
    
        // S‚Äôassurer de l‚Äôordre (casing sous le trait)
        try { map.moveLayer('note-links-casing'); } catch {}
        try { map.moveLayer('note-links-line'); } catch {}
        try { map.moveLayer('note-links-arrows'); } catch {}
      };
    
      if (!map.isStyleLoaded()) {
        const once = () => { add(); map.off('styledata', once); };
        map.once('load', add);
        map.on('styledata', once);
        return;
      }
      add();
    }

    // === Courbes entre points =====================================================
    // B√©zier quadratique en coord. g√©o (approx locale), force = √©cart au milieu
    function bezierCurveCoords(from, to, strength = 0.25, steps = 64){
      const p0 = [from.lon, from.lat];
      const p2 = [to.lon,   to.lat];
    
      // milieu
      const mx = (p0[0] + p2[0]) / 2;
      const my = (p0[1] + p2[1]) / 2;
    
      // vecteur p0->p2
      const vx = p2[0] - p0[0];
      const vy = p2[1] - p0[1];
    
      // vecteur normal (perpendiculaire) pour bomber la courbe
      const nx = -vy;
      const ny =  vx;
    
      // normaliser
      const len = Math.sqrt(nx*nx + ny*ny) || 1;
      const ux = nx / len;
      const uy = ny / len;
    
      // amplitude en degr√©s (~, reste raisonnable pour petites distances)
      const amp = strength * Math.hypot(vx, vy);
      const cx  = mx + ux * amp;
      const cy  = my + uy * amp;
    
      const coords = [];
      for (let i = 0; i <= steps; i++){
        const t = i / steps;           // 0..1
        const it = 1 - t;
        // Quadratic B√©zier : B(t) = (1‚àít)^2 P0 + 2(1‚àít)t C + t^2 P2
        const x = it*it*p0[0] + 2*it*t*cx + t*t*p2[0];
        const y = it*it*p0[1] + 2*it*t*cy + t*t*p2[1];
        coords.push([x, y]);
      }
      return coords;
    }
    
    // Arc g√©od√©sique (grand cercle) via Turf (si dispo)
    function geodesicCoords(from, to, steps = 64){
      if (!(window.turf && turf.greatCircle)) {
        // fallback : simple segment si Turf n'est pas charg√©
        return [[from.lon, from.lat],[to.lon, to.lat]];
      }
      const fc = turf.greatCircle(
        [from.lon, from.lat],
        [to.lon, to.lat],
        { npoints: Math.max(2, steps), properties: {} }
      );
      return fc.geometry.coordinates;
    }
    
    // Wrapper selon UI_CONFIG
    function curveBetween(from, to){
      const L = (UI_CONFIG && UI_CONFIG.links) || {};
      const style  = L.curveStyle || "bezier";
      const steps  = L.curveSteps || 64;
      if (style === "geodesic") return geodesicCoords(from, to, steps);
      const strength = L.curveStrength ?? 0.25;
      return bezierCurveCoords(from, to, strength, steps);
    }
    
    function drawLinksFrom(noteId, linkedIds){
      if (!map.getSource('note-links') || !map.getLayer('note-links-line')) {
        ensureLinksLayer();
      }
      const from = idToItem.get(noteId);
      if (!from) return;
      const features = [];
      linkedIds.forEach(lid => {
        const to = idToItem.get(lid);
        if (!to) return;
        const coords = curveBetween(from, to);
        features.push({
          type:'Feature',
          geometry:{ type:'LineString', coordinates: coords },
          properties:{ from: noteId, to: lid }
        });
      });
      const src = map.getSource('note-links');
      src.setData({ type:'FeatureCollection', features });
    }

    function clearLinks(){
      const src = map.getSource('note-links');
      if (src) src.setData({ type:'FeatureCollection', features:[] });
    }

    // === Donn√©es & Marqueurs & Filtres ===
    let allData = [];      // toutes les entr√©es JSON (charg√©es une fois)
    let allMarkers = [];   // { item, marker }
    let allTags = new Set();

    async function addMarkersFromJSON() {
      // charge data.json une seule fois
      if (allData.length === 0) {
        try {
          const res = await fetch('data.json', { cache: 'no-store' });
          allData = await res.json();
        } catch (e) {
          console.error('Erreur chargement data.json', e);
          return;
        }
      }

      // 3.3 ‚Äî index rapide id -> item (sert aux liens entre notes)
      idToItem.clear();
      allData.forEach(it => { if (it && it.id) idToItem.set(it.id, it); });

      // nettoie anciens marqueurs
      allMarkers.forEach(({marker}) => marker.remove());
      allMarkers = [];
      allTags.clear();

      // cr√©e les marqueurs
      allData.forEach(item => {
      // ‚ûï collecte les tags pour les filtres
        if (Array.isArray(item.tags)) {
          item.tags.forEach(t => { if (t && String(t).trim()) allTags.add(String(t).trim()); });
        }
        if (typeof item.lon === 'number' && typeof item.lat === 'number') {
          // STYLE du marqueur (rouge + bordure rouge fonc√©)
          const el = document.createElement('div');
          el.style.width = '14px';
          el.style.height = '14px';
          el.style.borderRadius = '50%';
          el.style.background = 'red';             // centre
          el.style.border = '2px solid darkred';   // contour
          el.style.boxShadow = '0 1px 6px rgba(0,0,0,0.3)';
          el.title = item.title || '';

          const marker = new maplibregl.Marker({ element: el })
            .setLngLat([item.lon, item.lat])
            .addTo(map);

          // Clic sur le marqueur => ouvre le panneau R√âSUM√â direct + traits
          el.addEventListener('click', async () => {
            await openSummaryInPanel(item.id); // affiche le r√©sum√© + liens + traits
          });


          allMarkers.push({ item, marker });
        }
      });

      // construit la liste de tags (si des tags existent)
      buildTagCheckboxes();
    }

    function buildTagCheckboxes(){
      const box = document.getElementById('tagsBox');
      if (!box) return;
      box.innerHTML = '';
      if (allTags.size === 0) {
        box.innerHTML = '<div style="color:#777; font-size:13px;">Aucun tag d√©tect√©</div>';
        return;
      }
      Array.from(allTags).sort((a,b)=>a.localeCompare(b)).forEach(tag => {
        const label = document.createElement('label');
        label.className = 'tag';
        const cb = document.createElement('input');
        cb.type = 'checkbox';
        cb.name = 'tag';
        cb.value = tag;
        const txt = document.createElement('span');
        txt.textContent = tag;
        label.appendChild(cb);
        label.appendChild(txt);
        box.appendChild(label);
      });
    }

    function applyFilters(){
      const q = (document.getElementById('filterQuery')?.value || '').toLowerCase().trim();
      const selected = Array.from(document.querySelectorAll('input[name="tag"]:checked')).map(i => i.value);

      // üîΩ Pays s√©lectionn√©s (multiselect)
      const sel = document.getElementById('filterCountry');
      const selectedCountries = sel ? Array.from(sel.selectedOptions).map(o => o.value) : [];

      allMarkers.forEach(({ item, marker }) => {
        let visible = true;

        // Filtre texte
        if (q) {
          const hay = [item.title||'', item.locationName||'', item.summary||''].join(' ').toLowerCase();
          visible = hay.includes(q);
        }

        // Filtre tags (ET logique)
        if (visible && selected.length) {
          const itags = Array.isArray(item.tags) ? item.tags.map(String) : [];
          visible = selected.every(t => itags.includes(t));
        }

        // üîΩ Filtre pays (OU logique entre pays s√©lectionn√©s)
        if (visible && selectedCountries.length) {
          const lon = item.lon, lat = item.lat;
          visible = selectedCountries.some(countryName => {
            const bbox = countriesBbox[countryName];
            return bbox ? pointInBbox(lon, lat, bbox) : false;
          });
        }

        marker.getElement().style.display = visible ? '' : 'none';
      });
    }

    function resetFilters(){
      // R√©initialiser recherche
      const q = document.getElementById('filterQuery');
      if (q) q.value = '';

      // R√©initialiser tags
      document.querySelectorAll('input[name="tag"]:checked').forEach(cb => cb.checked = false);

      // R√©initialiser pays
      const sel = document.getElementById('filterCountry');
      if (sel) Array.from(sel.options).forEach(o => o.selected = false);

      // R√©afficher tous les marqueurs
      allMarkers.forEach(({marker}) => marker.getElement().style.display = '');

      // Fermer le panneau
      const panel = document.getElementById('filtersPanel');
      if (panel) panel.style.display = 'none';

      // üîΩ Recentrer sur l‚ÄôEurope (constants)
      map.easeTo({ center: EUROPE_CENTER, zoom: DEFAULT_ZOOM, duration: 600 });
    }

    function zoomToVisibleMarkers(){
      const visibles = allMarkers.filter(({marker}) => marker.getElement().style.display !== 'none');
      if (visibles.length === 0) return;

      if (visibles.length === 1) {
        const [lon, lat] = visibles[0].marker.getLngLat().toArray();
        map.easeTo({ center: [lon, lat], zoom: 8, duration: 600 });
        return;
      }

      const bounds = new maplibregl.LngLatBounds();
      visibles.forEach(({marker}) => bounds.extend(marker.getLngLat()));
      map.fitBounds(bounds, { padding: 60, duration: 700 });
    }

    // Branche les boutons du panneau filtres
    document.getElementById('applyFilters')?.addEventListener('click', () => {
      applyFilters();
      zoomToVisibleMarkers(); // üîé recadre sur les r√©sultats filtr√©s
      document.getElementById('filtersPanel').style.display = 'none'; // ferme le panneau
    });
    document.getElementById('resetFilters')?.addEventListener('click', resetFilters);

    // Pays: tout s√©lectionner / tout d√©s√©lectionner
    document.getElementById('selectAllCountries')?.addEventListener('click', () => {
      const sel = document.getElementById('filterCountry');
      if (!sel) return;
      Array.from(sel.options).forEach(o => o.selected = true);
    });
    document.getElementById('clearAllCountries')?.addEventListener('click', () => {
      const sel = document.getElementById('filterCountry');
      if (!sel) return;
      Array.from(sel.options).forEach(o => o.selected = false);
    });

    // 3.5 ‚Äî Effacer les traits si on clique ailleurs que sur un marqueur
    map.on('click', (e) => {
      const path = e.originalEvent?.composedPath?.() || [];
      const clickedMarkerEl = path.find(n => n && n.classList && n.classList.contains('maplibregl-marker'));
      if (!clickedMarkerEl) {
        clearLinks();
      }
    });

  // === Fermeture du panneau (‚úñ) ===
  (function setupNotePanelClose(){
    const btn = document.getElementById('npClose');
    if (!btn) return;

    const closePanel = () => {
      const panel = document.getElementById('notePanel');
      if (panel) panel.style.display = 'none';
      // Efface les traits [[liens]] s'ils sont affich√©s
      if (typeof clearLinks === 'function') clearLinks();
    };

    btn.addEventListener('click', closePanel);

    // Bonus utile : fermer avec √âchap
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') closePanel();
    });
  })();
    
    // D√©marrage
    map.on('load', () => {
      addMarkersFromJSON().then(applyFilters);
      ensureLinksLayer();
      if (window.__lastLinksState) {
        drawLinksFrom(window.__lastLinksState.id, window.__lastLinksState.links);
      }
    });
    loadCountries();
    applyUIConfig();
  </script>
</body>
</html>
