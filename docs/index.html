<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <title>Carte interactive</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- MapLibre -->
  <link href="https://unpkg.com/maplibre-gl@5.7.3/dist/maplibre-gl.css" rel="stylesheet" />
  <script src="https://unpkg.com/maplibre-gl@5.7.3/dist/maplibre-gl.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@turf/turf@6/turf.min.js"></script>

  <!-- Marked (pour le panneau interne Markdown) -->
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>

  <style>
    html, body { margin:0; padding:0; height:100%; }
    #map {
      width: 100%;
      height: 100%;
      /* Donne un halo bleuté autour du globe (extérieur du cercle) */
      background: radial-gradient(circle at 50% 45%, #cfe4ff 0%, #e9f3ff 60%, #ffffff 100%);
    }

    #map.dark {
    /* Halo sombre/bleuté autour du globe */
    background: radial-gradient(circle at 50% 45%, #0a0f1f 0%, #0d1b2a 60%, #000000 100%);
  }
    
    
    .btn {
      display:inline-block; margin-top:6px; padding:8px 10px;
      background:#1e90ff; color:#fff; border:none; border-radius:8px;
      font-size:13px; cursor:pointer; width:100%; text-align:left;
      box-shadow:0 2px 8px rgba(30,144,255,.35);
    }
    .btn:hover { filter:brightness(.95); }

    /* Popup (carte) */
    .maplibregl-popup { max-width: 300px; font-family: system-ui, sans-serif; }
    .popup-title { font-size: 15px; font-weight: 600; margin-bottom: 4px; }
    .popup-meta  { font-size: 13px; color: #666; margin-bottom: 6px; }
    .popup-link  { display:inline-block; margin-top:6px; font-size:13px; color:#1e90ff; text-decoration:none; }
    .popup-link:hover { text-decoration: underline; }

    /* Bouton Filtres intégré au groupe de contrôles (en haut à droite) */
    .maplibregl-ctrl.filters-ctrl .filters-btn{
      min-width:60px; height:30px; display:flex; align-items:center; justify-content:center;
      font-size:14px; background:#fff; border:none; cursor:pointer;
    }

    /* Panneau de filtres (pop-up) en haut à droite */
    .filters-panel{
      position:absolute; top:115px; right:10px; z-index:10;
      width:360px; max-height:60vh; overflow:auto;
      background:#fff; border-radius:12px; padding:12px;
      box-shadow:0 8px 24px rgba(0,0,0,.18); font-family:system-ui, sans-serif; font-size:14px;
      display:none;
    }

    /* === Panneau latéral : Map views ================================== */
    .panel-toggle{
      position:absolute; top:10px; left:10px; z-index:11;
      width:36px; height:36px; border:none; border-radius:10px;
      background:#ffffff; box-shadow:0 6px 18px rgba(0,0,0,.18);
      font-size:18px; cursor:pointer; display:flex; align-items:center; justify-content:center;
    }
    /* Quand le panneau est ouvert, on cache le bouton toggle */
    .panel-toggle[aria-expanded="true"]{
      display: none;
    }

    .map-panel{
      position:absolute; top:10px; left:10px; z-index:10;
      width:260px; background:rgba(255,255,255,.92);
      backdrop-filter: blur(8px);
      border-radius:14px; box-shadow:0 10px 28px rgba(0,0,0,.2);
      font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif; font-size:14px;
      overflow:hidden; transition: transform .22s ease, opacity .22s ease;
    }
    .panel-hidden{ transform: translateX(-8px); opacity:0; pointer-events:none; }
    
    .panel-header{
      display:flex; align-items:center; justify-content:space-between;
      padding:10px 12px; border-bottom:1px solid #e5e7eb;
    }
    .panel-title{ font-weight:700; font-size:15px; }
    .panel-close{
      border:none;
      background:#dc2626;   /* rouge */
      color:#fff;
      border-radius:8px;
      padding:4px 8px;
      cursor:pointer;
      box-shadow:0 1px 4px rgba(0,0,0,.15);
    }
    .panel-close:hover{
      filter: brightness(.95);
    }

    /* Bordure noire pour mieux distinguer les petits boutons */
    #mapPanelToggle,
    .maplibregl-ctrl.filters-ctrl .filters-btn,
    .maplibregl-ctrl-zoom-in,
    .maplibregl-ctrl-zoom-out {
      border: 1px solid #000;  /* fine bordure noire */
    }
    
    .panel-group{ padding:10px 12px 0 12px; }
    .panel-subtitle{
      font-size:11px; letter-spacing:.04em; text-transform:uppercase;
      color:#6b7280; margin-bottom:6px; font-weight:600;
    }
    .radio-row{ display:flex; gap:8px; flex-wrap:wrap; }
    
    .radio-pill{
      display:inline-flex; align-items:center; gap:8px;
      border:1px solid #e5e7eb; border-radius:999px; background:#fff; padding:6px 10px;
      cursor:pointer; user-select:none; transition:all .15s ease;
    }
    .radio-pill:hover{ border-color:#cbd5e1; }
    .radio-pill input{ appearance:none; width:0; height:0; position:absolute; }
    .radio-pill input:checked + span{
      color:#fff;
    }
    .radio-pill:has(input:checked){
      background:#1e90ff; border-color:#1e90ff;
      box-shadow:0 2px 10px rgba(30,144,255,.35) inset, 0 0 0 1px rgba(255,255,255,.2);
    }
    
    .panel-actions{ padding:12px; display:grid; gap:8px; }



    
    .s-panel h3{ margin:0 0 8px; font-size:16px; }
    .s-panel .row{ margin:8px 0; }
    .s-panel input[type="text"]{ width:100%; padding:8px; border:1px solid #ddd; border-radius:8px; }
    .s-panel .tags{ display:flex; flex-wrap:wrap; gap:6px; }
    .s-panel .tag{
      display:flex; align-items:center; gap:6px; padding:6px 8px; border:1px solid #e5e7eb; border-radius:8px;
    }
    .filters-actions{ display:flex; gap:8px; margin-top:10px; }
    .filters-actions button{
      flex:1; padding:8px; border:none; border-radius:8px; cursor:pointer;
    }
    .filters-apply{ background:#1e90ff; color:#fff; }
    .filters-reset{ background:#f3f4f6; }

    /* Panneau interne (lecture des notes) */
    .internal-link { text-decoration: none; border-bottom: 1px dashed #1e90ff;
    }
    .internal-link:hover { text-decoration: underline; }

        :root { --recap-lines: 2; }
        /* Récap réduit sur N lignes (piloté par --recap-lines) */
        #npRecap.clamped {
          display: -webkit-box;
          -webkit-box-orient: vertical;
          -webkit-line-clamp: var(--recap-lines);
          overflow: hidden;
        }
    
        /* Lien de bascule [...] / ↥ réduire */
        #npRecapToggle {
          cursor: pointer;
          display: inline-block;
          margin-top: 4px;
          text-decoration: underline;
          font-style: italic;
          user-select: none;
          font-size: 0.85em;   /* ↩️ taille relative au récap */
          font-weight: normal; /* ↩️ plus léger */
        }
    
    /* Curseur clair quand c’est cliquable */
    .maplibregl-marker,
    .internal-link,
    #npFit,
    .basemap-control .segmented-group .seg-btn,
    .maplibregl-ctrl button,
    .filters-ctrl .filters-btn {
      cursor: pointer;
    }
    
    /* Bordures noires fines sur les contrôles pour mieux les voir */
    .maplibregl-ctrl-group > button,
    .filters-ctrl .filters-btn {
      border: 1px solid #000 !important;
    }
    
    /* Au survol, un léger relief pour le feedback */
    .maplibregl-ctrl-group > button:hover,
    .filters-ctrl .filters-btn:hover,
    .basemap-control .segmented-group .seg-btn:hover {
      filter: brightness(.95);
    }
    /* Marqueur actif (après clic) */
    .marker--active{
      background-color:#0d8f06 !important; /* force la couleur même si le marqueur a un style inline */
      transform: scale(1.12);
      box-shadow: 0 0 0 2px #fff, 0 2px 10px rgba(0,0,0,.35);
    }
  </style>
</head>
<body>
  <div id="map"></div>

  <!-- Panneau de lecture interne -->
  <div id="notePanel" style="position:absolute;right:10px;top:10px;width:400px;max-height:88vh;overflow:auto;background:#fff;border-radius:12px;box-shadow:0 8px 24px rgba(0,0,0,.18);padding:0;display:none;z-index:12;font-family:system-ui;">
    <!-- En-tête jaune -->
    <div id="npHeader" style="background:#facc15;padding:10px 12px;border-radius:12px 12px 0 0;border-bottom:1px solid #0f172a22; position:sticky; top:0; z-index:20;box-shadow:0 4px 8px rgba(0,0,0,.35);">
      <!-- Bouton croix en haut-droite -->
      <button id="npClose" type="button" aria-label="Fermer"
              style="position:absolute; top:8px; right:10px;
                     width:26px; height:26px;
                     display:flex; align-items:center; justify-content:center;
                     border:none; border-radius:6px;
                     background:#dc2626; color:#fff; cursor:pointer;
                     box-shadow:0 1px 4px rgba(0,0,0,.15);">
        ✖
      </button>
      <div id="npTitle" style="font-size:16px;font-weight:700;">Titre</div>
    
      <!-- Lieu avec 📍 -->
      <div id="npMeta" style="font-size:12px;opacity:.9;display:flex;align-items:center;gap:6px;margin-top:4px;">
        <span id="npIcon" style="font-size:14px;line-height:1">📍</span>
        <span id="npPlace">Pays, ville</span>
      </div>
      
      <!-- Date avec 🕓 -->
      <div id="npDate" style="font-size:12px;opacity:.8;display:flex;align-items:center;gap:6px;margin-top:2px; margin-left:20px;">
        <span id="npDateIcon" style="font-size:14px;line-height:1">🕓</span>
        <span id="npDateText">6 octobre 1981</span>
      </div>
    
       <!-- Phrase récap (optionnelle) -->
      <div id="npRecap" style="margin-top:6px; font-weight:600; font-style:italic;"></div>
      <a id="npRecapToggle" href="#" style="display:none;"></a>
    </div>


    <!-- Corps clair (marges homogènes) -->
    <div id="npWrapper" style="padding:6px 6px;">
      <div id="npCard" style="border:1px solid #0f172a22;border-radius:10px;padding:10px;background:#fef9c3;">
        <!-- Petite phrase avant la note (optionnelle) -->
        <div id="npSummary" style="font-size:14px;line-height:1.55;margin-bottom:8px;"></div>
        <!-- Markdown complet de la note -->
        <div id="npMd" style="font-size:14px;line-height:1.55;"></div>
      </div>
        
      <!-- Liens sortants -->
      <div id="npLinksWrap" style="margin-top:10px;">
        <div style="font-weight:700;margin:8px 0 6px;">Liens sortants</div>
        <div id="npLinks" style="font-size:14px;"></div>
        <div style="margin-top:8px;display:flex;gap:8px;">
          <button id="npFit"  type="button" style="padding:6px 8px;border:1px solid #e5e7eb;border-radius:6px;background:#fff;cursor:pointer;">🔎 Voir les liés</button>
        </div>
      </div>
    </div>
    </div>

  <!-- Panneau latéral (haut-gauche) : Map views -->
  <button id="mapPanelToggle" class="panel-toggle" aria-expanded="false" aria-controls="mapPanel" title="Afficher/masquer les options carte">🗺️</button>
  
  <aside id="mapPanel" class="map-panel panel-hidden" aria-label="Options de carte">
    <header class="panel-header">
      <span class="panel-title">Map views</span>
      <button id="mapPanelClose" class="panel-close" aria-label="Masquer le panneau">✕</button>
    </header>
  
    <section class="panel-group">
      <div class="panel-subtitle">Projection</div>
      <div class="radio-row">
        <label class="radio-pill">
          <input type="radio" name="projection" value="mercator">
          <span>2D</span>
        </label>
        <label class="radio-pill">
          <input type="radio" name="projection" value="globe" checked>
          <span>3D</span>
        </label>
      </div>
    </section>
  
    <section class="panel-group">
      <div class="panel-subtitle">Style</div>
      <div class="radio-row">
        <label class="radio-pill">
          <input type="radio" name="basemap" value="streets" checked>
          <span>Streets</span>
        </label>
        <label class="radio-pill">
          <input type="radio" name="basemap" value="light">
          <span>Light</span>
        </label>
        <label class="radio-pill">
          <input type="radio" name="basemap" value="dark">
          <span>Dark</span>
        </label>
      </div>
    </section>
  
    <section class="panel-actions">
      <button id="recenterEurope" class="btn" type="button">Recentrer Europe</button>
      <button id="recenterWorld" class="btn" type="button">Recentrer Monde</button>
    </section>
  </aside>

  <!-- Panneau Filtres (pop-up) -->
  <div id="filtersPanel" class="filters-panel s-panel">
    <h3>Filtres</h3>

    <!-- Recherche -->
    <div class="row">
      <label>Recherche</label>
      <input type="text" id="filterQuery" placeholder="Titre, lieu, résumé…" />
    </div>

    <!-- Tags -->
    <div class="row">
      <label>Tags</label>
      <div id="tagsBox" class="tags"></div>
    </div>

    <!-- Pays -->
    <div class="row">
      <label>Pays</label>
      <select id="filterCountry" multiple size="6" style="width:100%; border:1px solid #ddd; border-radius:8px; padding:6px;">
        <!-- rempli dynamiquement -->
      </select>
      <div style="display:flex; gap:8px; margin-top:6px;">
        <button id="selectAllCountries"  class="filters-reset" type="button" style="flex:1;">Tout sélectionner</button>
        <button id="clearAllCountries"   class="filters-reset" type="button" style="flex:1;">Tout désélectionner</button>
      </div>
    </div>

    <!-- Actions -->
    <div class="row">
      <div class="filters-actions">
        <button class="filters-apply" id="applyFilters" type="button">Appliquer</button>
        <button class="filters-reset" id="resetFilters" type="button">Réinitialiser</button>
      </div>
    </div>
  </div>



  
  <script>
    // 🔑 Mets ta clé MapTiler ici
    const MAPTILER_KEY = "MLrpRZ0Wo2Dsvsj13UYN"; // remplace si besoin


 
    const UI_CONFIG = {
    panel: {
      width: "400px",            // Largeur du panneau latéral (ex: "400px" ou "30vw")
      marginRight: "10px",       // Espace entre le panneau et le bord droit de la carte
      marginTop: "10px",         // Espace entre le haut du panneau et la carte
      background: "#fff",        // Couleur de fond du panneau
      shadow: "0 8px 24px rgba(0,0,0,.18)", // Ombre portée (box-shadow)
      borderRadius: "12px"       // Arrondi des coins du panneau
    },
      
    header: {
      background: "#facc15",     // Couleur de fond du bandeau jaune (en-tête)
      textColor: "#000",         // Couleur du texte dans l’en-tête
      titleSize: "16px",         // Taille du titre (px)
      locationIcon: "📍",        // Icône affichée avant la localisation
      dateIndent: "0px",        // Décalage gauche de la date (alignement sous la localisation)
      dateFormat: {              // Format de la date (Intl API)
        day: "numeric",
        month: "long",
        year: "numeric"
      },
      recapFontSize: "12px",
      recapStyle: "font-weight:600; font-style:italic;",        // Style appliqué à la phrase récap (gras, italique, couleur…)
      recapMaxLines: 2,                    // ← nombre de lignes visibles
      recapMoreLabel: " […]",              // ← libellé pour déployer
      recapLessLabel: " ↥ réduire"         // ← libellé pour « retrousser »
    },
    
    card: {
      background: "#fef9c3",     // Couleur du bloc jaune clair (contenu)
      border: "1px solid #0f172a22", // Bordure autour du bloc jaune clair
      borderRadius: "10px",      // Arrondi du bloc jaune clair
      outerPadding: "8px 10px",  // Marge BLANCHE autour du bloc jaune clair (écart avec le panneau)
      innerPadding: "10px",      // Marge INTERNE du bloc jaune clair (espace texte ↔ bord du bloc)
      fontSize: "14px",          // Taille du texte dans la note
      lineHeight: "1.55"         // Interligne du texte
    },
    
    links: {
      sectionTitle: "Liens sortants",     // Titre affiché au-dessus de la liste
      internalLinkColor: "#1e90ff",       // Couleur des liens internes [[...]]
      internalLinkUnderline: "dashed",    // Style soulignement (dashed, solid, none)
    
      // === Style visuel des traits sur la carte ===
      lineColor: "#9e0909",    // couleur de la ligne
      lineWidth: 2.5,          // épaisseur en px
      lineOpacity: 0.95,       // transparence (0-1)
      lineDasharray: null,     // [4,2] pour pointillés, null = plein
      casingColor: "#470303",  // couleur du contour (pour contraste)
      casingWidth: 0,          // largeur du contour (0 = pas de contour)
    
      // === Géométrie des courbes ===
      curveStyle: "bezier",    // "bezier" | "geodesic"
      curveStrength: 0.3,     // Bézier : 0.15 (léger) à 0.5 (prononcé)
      curveSteps: 96           // nombre de points par courbe

      // Petites recettes visuelles: 
          // Carte locale / urbaine : curveStyle:"bezier", curveStrength:0.18, curveSteps:48 
          // Pays / continent : curveStyle:"bezier", curveStrength:0.25, curveSteps:64 
          // Intercontinental (vols, routes mondiales) : curveStyle:"geodesic", curveSteps:96 
          // Style “fils tendus” minimaliste : curveStyle:"straight", curveSteps:2, lineDasharray:[4,2], lineOpacity:0.6
    },
    
    buttons: {
      fitText: "🔎 Voir les liés", // Texte du bouton pour recadrer sur les notes liées
      closeText: "✖ Fermer",      // Texte du bouton pour fermer le panneau
      background: "#fff",         // Couleur de fond des boutons
      borderRadius: "6px"         // Arrondi des boutons
    }
  };



    // Crée/actualise une balise <style> dédiée aux overrides UI
    function setUIStyle(css){
      let tag = document.getElementById('ui-overrides');
      if (!tag) {
        tag = document.createElement('style');
        tag.id = 'ui-overrides';
        document.head.appendChild(tag);
      }
      tag.textContent = css;
    }
    
    // Applique le UI_CONFIG sur le panneau déjà présent dans le DOM
    function applyUIConfig(){
      // Variables pratiques
      const P = UI_CONFIG.panel;
      const H = UI_CONFIG.header;
      const C = UI_CONFIG.card;
      const L = UI_CONFIG.links;
      const B = UI_CONFIG.buttons;
    
      // Styles dynamiques (CSS) pour classes/ids existants
      setUIStyle(`
        /* Panneau conteneur */
        #notePanel{
          width:${P.width};
          right:${P.marginRight};
          top:${P.marginTop};
          background:${P.background};
          box-shadow:${P.shadow};
          border-radius:${P.borderRadius};
        }
        /* En-tête */
        #npHeader{
          background:${H.background};
          color:${H.textColor};
        }
        #npTitle{ font-size:${H.titleSize}; }
        #npDate{ margin-left:${H.dateIndent}; }
        #npRecap{ ${H.recapStyle}; font-size:${H.recapFontSize || "13px"}; width:100%; text-align:justify; }
    
        /* Bloc contenu */
        #npWrapper{ padding:${C.outerPadding}; }
        #npCard{
          background:${C.background};
          border:${C.border};
          border-radius:${C.borderRadius};
          padding:${C.innerPadding};
          font-size:${C.fontSize};
          line-height:${C.lineHeight};
        }
    
        /* Liens internes */
        .internal-link{
          text-decoration: none;
          border-bottom: 1px ${L.internalLinkUnderline} ${L.internalLinkColor};
          color: inherit;
        }
        .internal-link:hover{ text-decoration: underline; }
    
        /* Boutons */
        #npLinksWrap button{
          background:${B.background};
          border-radius:${B.borderRadius};
        }
      `);
    
      // Texte/icone dynamiques
      const icon = document.getElementById('npIcon');
      if (icon) icon.textContent = H.locationIcon;
    
      // Titres/labels dynamiques
      const linksTitle = document.querySelector('#npLinksWrap > div:first-child');
      if (linksTitle) linksTitle.textContent = L.sectionTitle;
    
      const btnFit  = document.getElementById('npFit');
      if (btnFit) btnFit.textContent = B.fitText;
      // Pas de texte pour la croix : on laisse le symbole ✖ dans le HTML du header

      // Propager le nombre de lignes vers le CSS (line-clamp)
      document.documentElement.style.setProperty('--recap-lines', String((UI_CONFIG.header && UI_CONFIG.header.recapMaxLines) || 2));
      
    }

    // Utilitaire: debounce simple
    function debounce(fn, wait=120){ let t; return (...a)=>{ clearTimeout(t); t=setTimeout(()=>fn(...a), wait); }; }
    
    // Utilitaire: convertir HTML -> texte brut (pour ne pas couper au milieu d'une balise)
    function htmlToText(html){
      const d = document.createElement('div');
      d.innerHTML = html;
      return d.textContent || d.innerText || '';
    }

    // Renvoie une hauteur de ligne en pixels (gère le cas 'normal')
    function resolveLineHeight(el){
      const cs = getComputedStyle(el);
      const lh = cs.lineHeight;
      if (!lh || lh === 'normal') {
        const fs = parseFloat(cs.fontSize) || 14;
        return Math.round(fs * 1.33); // approximation standard du 'normal'
      }
      const n = parseFloat(lh);
      return isNaN(n) ? 18 : n;
    }
    
    // Tronque #npRecap à N lignes, ajoute [...] / ↥ réduire, sans couper de mot.
    // Mesure robuste via un conteneur invisible à largeur fixe.
    function clampRecap(maxLines){
      const wrap = document.getElementById('npRecap');
      if (!wrap) return;
    
      const width = wrap.clientWidth || wrap.getBoundingClientRect().width || 0;
      if (width <= 0) {
        requestAnimationFrame(() => clampRecap(maxLines));
        return;
      }
    
      const H = UI_CONFIG.header;
      const moreLabel = H.recapMoreLabel || ' […]';
      const lessLabel = H.recapLessLabel || ' ↥ réduire';
      const lines = maxLines || 2;

    
      // HTML complet déjà injecté par openSummaryInPanel (on le garde pour l'état "étendu")
      const fullHtml = wrap.innerHTML.trim();
      if (!fullHtml){
        wrap.innerHTML = '';
        return;
      }
    
      // Texte brut (pour tronquer proprement au mot)
      const tmp = document.createElement('div');
      tmp.innerHTML = fullHtml;
      const fullText = (tmp.textContent || tmp.innerText || '').trim();
    
      // ----- Mesureur invisible à largeur fixe -----
      // On copie les styles de wrap pour une mesure fidèle
      const cs = getComputedStyle(wrap);
      const meas = document.createElement('div');
      meas.style.position = 'absolute';
      meas.style.left = '-9999px';
      meas.style.top = '-9999px';
      meas.style.visibility = 'hidden';
      meas.style.whiteSpace = 'normal';
      meas.style.wordBreak = 'break-word';
      meas.style.width = wrap.clientWidth + 'px';
      meas.style.fontSize = cs.fontSize;
      meas.style.lineHeight = (cs.lineHeight === 'normal')
        ? (parseFloat(cs.fontSize || '14') * 1.33) + 'px'
        : cs.lineHeight;
      meas.style.fontFamily = cs.fontFamily;
      meas.style.fontWeight = cs.fontWeight;
      meas.style.fontStyle  = cs.fontStyle;
      meas.style.letterSpacing = cs.letterSpacing;
      document.body.appendChild(meas);
    
      const lineH = parseFloat(meas.style.lineHeight) || 18;
      const maxH  = Math.ceil(lineH * lines);
    
      // Fonction de mesure
      const heightFor = (text) => {
        meas.textContent = text;
        return meas.scrollHeight;
      };
    
      // Si tout tient déjà en <= N lignes → pas de bouton
      if (heightFor(fullText) <= maxH + 1){
        wrap.innerHTML = fullHtml;
        document.body.removeChild(meas);
        return;
      }
    
      // ----- Construire l’UI (span + toggle) -----
      wrap.innerHTML = '';
      const span = document.createElement('span');
      span.id = 'npRecapText';
      span.style.display = 'block';
      span.style.width = '100%';
      span.style.whiteSpace = 'normal';
      span.style.wordBreak = 'break-word';
    
      const toggle = document.createElement('a');
      toggle.id = 'npRecapToggle';
      toggle.className = 'np-recap-toggle';
      toggle.href = '#';
      toggle.style.marginLeft = '2px';
    
      wrap.appendChild(span);
      wrap.appendChild(toggle);
    
      // ----- Recherche dichotomique au mot près -----
      const words = fullText.split(/\s+/);
      let lo = 0, hi = words.length, best = 0;
      while (lo <= hi){
        const mid = (lo + hi) >> 1;
        const probe = words.slice(0, mid).join(' ').trim();
        if (heightFor(probe) <= maxH + 1){ best = mid; lo = mid + 1; }
        else { hi = mid - 1; }
      }
      let truncated = words.slice(0, best).join(' ').trim();
    
      // Appliquer l’état réduit
      let expanded = false;
      const setExpanded = (on) => {
        expanded = on;
        if (expanded){
          span.innerHTML = fullHtml;   // on remet l’HTML complet (gras/italique conservés)
          toggle.textContent = lessLabel;
        } else {
          span.textContent = truncated;
          toggle.textContent = moreLabel;
        }
      };
      setExpanded(false);
    
      toggle.addEventListener('click', (e) => {
        e.preventDefault();
        setExpanded(!expanded);
      });
    
      // Recalibrer si la largeur change (quand replié)
      const onResize = (() => {
        let t; return () => {
          clearTimeout(t); t = setTimeout(() => {
            if (expanded) return;
            // Recalcule la largeur du mesureur + tronquage
            meas.style.width = wrap.clientWidth + 'px';
            lo = 0; hi = words.length; best = 0;
            while (lo <= hi){
              const mid = (lo + hi) >> 1;
              const probe = words.slice(0, mid).join(' ').trim();
              if (heightFor(probe) <= maxH + 1){ best = mid; lo = mid + 1; }
              else { hi = mid - 1; }
            }
            truncated = words.slice(0, best).join(' ').trim();
            setExpanded(false);
          }, 160);
        };
      })();
      window.addEventListener('resize', onResize);
    
      // Nettoyage du mesureur (on le garde si on veut recalculer → ici on le retire)
      document.body.removeChild(meas);
    }


    // Styles MapTiler (vector)
    const STYLES = {
      streets:`https://api.maptiler.com/maps/streets/style.json?key=${MAPTILER_KEY}`,
      light:  `https://api.maptiler.com/maps/basic/style.json?key=${MAPTILER_KEY}`,
      dark:   `https://api.maptiler.com/maps/dataviz-dark/style.json?key=${MAPTILER_KEY}`
    };

    // Provider & style courants
    let CURRENT_BASEMAP  = 'streets';    // 'hybrid' | 'streets' | 'light' | 'dark'
    let CURRENT_PROJECTION = 'globe'; // 'mercator' | 'globe'
    
    function getStyleURL(basemap){
      return STYLES[basemap] || STYLES.streets;
    }

    function applyProjection() {
      const type = (CURRENT_PROJECTION === 'globe') ? 'globe' : 'mercator';
      try { map.setProjection({ type }); } catch (err) { console.warn('Projection non supportée:', err); }
    
      if (type === 'globe') {
      // teinte l’horizon et l’extérieur du globe
      map.setFog({
        range: [0.5, 10],
        color: 'rgba(160,190,220,0.9)',
        'horizon-blend': 0.25
      });
      startSun();
    } else {
      map.setFog(null);
      if (__sunTimer) { clearInterval(__sunTimer); __sunTimer = null; }
    }
  }

    // Met à jour la position du "soleil"
    function updateSun() {
      const now = new Date();
      const t = (now.getHours() + now.getMinutes() / 60) / 24; // 0..1
      const azimuth = t * 360;
      const altitude = Math.sin(t * 2 * Math.PI) * 35 + 25; // -10..60
    
      try {
        map.setPaintProperty('sky', 'sky-atmosphere-sun', [azimuth, altitude]);
      } catch {}
    }

    function ensureTerrain() {
      if (CURRENT_PROJECTION !== 'globe') {
        try { map.setTerrain(null); } catch {}
        return;
      }
    
      if (!map.getSource('terrain-dem')) {
        map.addSource('terrain-dem', {
          type: 'raster-dem',
          url: `https://api.maptiler.com/tiles/terrain-rgb-v2/tiles.json?key=${MAPTILER_KEY}`,
          tileSize: 512,
          maxzoom: 14
        });
      }
      try {
        map.setTerrain({ source: 'terrain-dem', exaggeration: 1.4 });
        // Ombres portées du relief (visibles même de dessus)
        if (!map.getLayer('terrain-hillshade')) {
          map.addLayer({
            id: 'terrain-hillshade',
            type: 'hillshade',
            source: 'terrain-dem',
            paint: {
              'hillshade-exaggeration': 0.6,
              'hillshade-shadow-color': '#000',
              'hillshade-highlight-color': '#fff'
            }
          }, 'note-links-casing'); // l’ajouter sous tes traits/labels
        }
      } catch (e) {
        console.warn('Impossible de définir le terrain:', e);
      }
    }
          
    let __sunTimer = null;
    function startSun() {
      updateSun();
      clearInterval(__sunTimer);
      __sunTimer = setInterval(updateSun, 30000);
    }
    
    // === Liens façon Obsidian entre notes (globals) ===
    const NOTE_RAW_BASE = 'https://raw.githubusercontent.com/antoninbld/geo_map_notes/main/docs/notes';
    const idToItem = new Map();     // id -> item (depuis data.json)
    const linksCache = new Map();   // id -> [linkedId, ...]
    let linksSourceReady = false;   // source/layer pour les traits
    window.__lastLinksState = null; // dernier état dessiné

    // 🎯 Vues par défaut
    const DEFAULT_ZOOM   = 3.8;
    const EUROPE_CENTER  = [10, 50];
    const WORLD_CENTER   = [0, 20];   // Atlantique, vue équilibrée
    const WORLD_ZOOM     = 2.2;       // zoom faible = vue globale

    // Carte
    const map = new maplibregl.Map({
      container: 'map',
      style: getStyleURL(CURRENT_BASEMAP), // ← plus de provider
      center: WORLD_CENTER,
      zoom:   WORLD_ZOOM,
      projection: 'globe'
    });
    map.on('style.load', applyProjection); // réapplique la projection à chaque changement de style

    // 🔹 Au tout premier chargement du style, on crée les marqueurs et la couche des liens
    map.on('load', () => {
      addMarkersFromJSON().then(() => {
        applyFilters({ skipFit: true }); // pas de recadrage auto au boot
      });
    
      // 3D + Monde par défaut
      CURRENT_PROJECTION = 'globe';
      applyProjection();
      ensureTerrain?.();
      if (typeof recenterWorld === 'function') {
        recenterWorld();
      } else {
        map.easeTo({ center: [0, 20], zoom: 1.4, duration: 0 });
      }
    
      ensureLinksLayer();
      if (window.__lastLinksState) {
        drawLinksFrom(window.__lastLinksState.id, window.__lastLinksState.links);
      }
    });
    
    map.on('style.load', () => {
      CURRENT_PROJECTION = 'globe';
      applyProjection();
      ensureTerrain?.();
    
      ensureLinksLayer();
      if (window.__lastLinksState) {
        drawLinksFrom(window.__lastLinksState.id, window.__lastLinksState.links);
      }
    });

    // (debug utile)
    map.on('error', (e) => console.error('Map error:', e && (e.error || e)));

    // Contrôles zoom (en haut à droite)
    map.addControl(new maplibregl.NavigationControl({ showCompass: false }), 'top-right');

    // Bouton "Filtres" à côté du +/-
    class FilterControl {
      onAdd(map){
        this._map = map;
        const group = document.createElement('div');
        group.className = 'maplibregl-ctrl maplibregl-ctrl-group filters-ctrl';

        const btn = document.createElement('button');
        btn.className = 'filters-btn';
        btn.type = 'button';
        btn.title = 'Filtres';
        btn.textContent = 'Filtres';
        btn.addEventListener('click', () => {
          const panel = document.getElementById('filtersPanel');
          panel.style.display = panel.style.display === 'none' || !panel.style.display ? 'block' : 'none';
        });

        // Ferme le panneau filtres si on clique ailleurs
        document.addEventListener('click', (e) => {
          const panel = document.getElementById('filtersPanel');
          const btn = document.querySelector('.filters-btn');
          if (!panel || !btn) return;
          if (panel.style.display === 'block' && !panel.contains(e.target) && !btn.contains(e.target)) {
            panel.style.display = 'none';
          }
        });

        group.appendChild(btn);
        this._container = group;
        return group;
      }
      onRemove(){ this._container.remove(); this._map = undefined; }
    }
    map.addControl(new FilterControl(), 'top-right');

    // Labels visibles après changement de style
    function setLabelVisibility(visible) {
      const style = map.getStyle();
      if (!style || !style.layers) return;
      style.layers.forEach(layer => {
        const isText = layer.type === 'symbol' && layer.layout && layer.layout['text-field'];
        const looksLikeLabel = /label|place|country|state|city|town|village/i.test(layer.id);
        if (isText || looksLikeLabel) {
          try { map.setLayoutProperty(layer.id, 'visibility', visible ? 'visible' : 'none'); } catch {}
        }
      });
    }

    // === Pays: bbox & helpers ===
    let countriesBbox = {}; // nom -> [minLon, minLat, maxLon, maxLat]

    async function loadCountries(){
      try{
        const res = await fetch('countries-bbox.json', { cache: 'no-store' });
        countriesBbox = await res.json();
        buildCountrySelect();
      }catch(e){
        console.error('Erreur chargement countries-bbox.json', e);
      }
    }

    function buildCountrySelect(){
      const sel = document.getElementById('filterCountry');
      if (!sel) return;
      sel.innerHTML = '';
      Object.keys(countriesBbox).sort((a,b)=>a.localeCompare(b)).forEach(name => {
        const opt = document.createElement('option');
        opt.value = name;
        opt.textContent = name;
        sel.appendChild(opt);
      });
    }

    // Permet de cocher/décocher les pays par simple clic (sans Ctrl/⌘)
    const countrySel = document.getElementById('filterCountry');
    if (countrySel) {
      countrySel.addEventListener('mousedown', (e) => {
        const opt = e.target;
        if (opt.tagName === 'OPTION') {
          e.preventDefault();            // évite la sélection exclusive
          opt.selected = !opt.selected;  // toggle
          countrySel.dispatchEvent(new Event('change', { bubbles: true }));
        }
      });
    }

    function pointInBbox(lon, lat, bbox){
      const [minX, minY, maxX, maxY] = bbox;
      return lon >= minX && lon <= maxX && lat >= minY && lat <= maxY;
    }

    // Recentrages
    function recenterEurope() {
      map.easeTo({ center: EUROPE_CENTER, zoom: DEFAULT_ZOOM, duration: 600 });
    }
    function recenterWorld() {
      map.easeTo({ center: WORLD_CENTER, zoom: WORLD_ZOOM, duration: 800 });
    }
    document.getElementById('recenterEurope').addEventListener('click', recenterEurope);
    document.getElementById('recenterWorld').addEventListener('click', recenterWorld);

    // Raccourcis clavier : E (Europe), U (USA)
    window.addEventListener('keydown', (e) => {
      const key = e.key.toLowerCase();
      if (key === 'e') recenterEurope();
      if (key === 'u') recenterUSA();
    });

    // Changement de fond (robuste pour recréer la couche liens)
    document.querySelectorAll('input[name="basemap"]').forEach(radio => {
      radio.addEventListener('change', (e) => {
        const choice = e.target.value;          // 'hybrid' | 'streets' | 'light' | 'dark'
        CURRENT_BASEMAP = choice;
        updateMapBackgroundClass();
        
        map.setStyle(getStyleURL(CURRENT_BASEMAP));
        
        const rebuild = () => {
          applyProjection();
          ensureTerrain();
          addMarkersFromJSON().then(() => {
            applyFilters?.();
            ensureLinksLayer();
            if (window.__lastLinksState) {
              const { id, links } = window.__lastLinksState;
              drawLinksFrom(id, links);
            }
          });
        };
        
        // 🔁 certains styles déclenchent différemment : on écoute les trois
        map.once('load', rebuild);
        map.once('styledata', rebuild);
        map.once('style.load', rebuild);
      });
    });

    function updateMapBackgroundClass(){
      const mapDiv = document.getElementById('map');
      if (!mapDiv) return;
      // On met le gradient sombre uniquement si le basemap choisi est "dark"
      if (CURRENT_BASEMAP === 'dark') mapDiv.classList.add('dark');
      else mapDiv.classList.remove('dark');
    }
    
    window.addEventListener('load', updateMapBackgroundClass);
    window.addEventListener('load', () => {
      // Force la valeur par défaut à 'globe' et synchronise le radio
      CURRENT_PROJECTION = 'globe';
      const globeRadio = document.querySelector('input[name="projection"][value="globe"]');
      if (globeRadio) globeRadio.checked = true;
      applyProjection();
      ensureTerrain(); // active le relief si dispo
    });
    
    // Projection (2D / 3D)
    document.querySelectorAll('input[name="projection"]').forEach(radio => {
      radio.addEventListener('change', (e) => {
        CURRENT_PROJECTION = e.target.value; // 'mercator' | 'globe'
        applyProjection();
        ensureTerrain();
    
        // Pour bien voir la sphère la 1ère fois :
        if (CURRENT_PROJECTION === 'globe' && map.getZoom() > 2) {
          map.easeTo({ center: [0, 20], zoom: 1.2, pitch: 40, bearing: 0, duration: 500 });
        }
      });
    });
      
    // === Helpers Obsidian/panneau ===
    function parseAndStripFrontMatter(text){
      let meta = {};
      if (text.startsWith('---')) {
        const end = text.indexOf('\n---', 3);
        if (end !== -1) {
          const fm = text.slice(3, end).trim();
          text = text.slice(end + 4).trimStart();
          fm.split('\n').forEach(line => {
            const idx = line.indexOf(':');
            if (idx > -1) {
              const key = line.slice(0, idx).trim();
              let val = line.slice(idx + 1).trim();
              if ((val.startsWith('"') && val.endsWith('"')) || (val.startsWith("'") && val.endsWith("'"))) {
                val = val.slice(1, -1);
              }
              meta[key] = val;
            }
          });
        }
      }
      return { meta, body: text };
    }

    function transformWikiLinks(md){
      return md.replace(/\[\[([^\]\|]+)(?:\|([^\]]+))?\]\]/g, (m, rawId, label) => {
        const id = String(rawId||'').trim();
        if (!id) return m;
        const txt = String(label||id).trim();
        return `[${txt}](note.html?id=${encodeURIComponent(id)})`;
      });
    }

    // === Récap: gestion via CSS (clamp) + toggle ===================================
    function updateRecapToggleLabel(collapsed) {
      const t = document.getElementById('npRecapToggle');
      if (!t) return;
      const H = (window.UI_CONFIG && UI_CONFIG.header) || {};
      t.textContent = collapsed ? (H.recapMoreLabel || ' […]') : (H.recapLessLabel || ' ↥ réduire');
    }

    function setupRecapToggle() {
      const wrap = document.getElementById('npRecap');
      const t = document.getElementById('npRecapToggle');
      if (!wrap || !t) return;

      const hasText = !!wrap.textContent.trim();
      t.style.display = hasText ? 'inline-block' : 'none';
      if (!hasText) return;

      // État initial: réduit
      wrap.classList.add('clamped');
      updateRecapToggleLabel(true);

      t.onclick = (e) => {
        e.preventDefault();
        const collapsed = wrap.classList.toggle('clamped'); // true si réduit après toggle
        updateRecapToggleLabel(collapsed);
      };
    }

    function setRecapText(text) {
      const wrap = document.getElementById('npRecap');
      if (!wrap) return;
      // On rend les [[liens]] cliquables dans le récap
      wrap.innerHTML = text ? renderWikiLinksInline(text) : '';
      setupRecapToggle();
    }

    async function openNoteInPanel(noteId){
      try{
        const url = `${NOTE_RAW_BASE}/${encodeURIComponent(noteId)}.md`;
        const res = await fetch(url, { cache:'no-store' });
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        const md = await res.text();
        const { meta, body } = parseAndStripFrontMatter(md);
        const html = marked.parse(transformWikiLinks(body));

        document.getElementById('npTitle').textContent =
          (meta.title && meta.title.trim()) || (idToItem.get(noteId)?.title || noteId);
        const $npBody = document.getElementById('npMd');
        $npBody.innerHTML = html;
        document.getElementById('notePanel').style.display = 'block';

        // Interception des liens internes du panneau
        $npBody.querySelectorAll('a[href^="note.html?id="]').forEach(a => {
          a.classList.add('internal-link');
          a.addEventListener('click', (e) => {
            e.preventDefault();
            const href = a.getAttribute('href');
            const id = decodeURIComponent(href.split('id=')[1] || '');
            if (!id) return;

            openNoteInPanel(id);

            getOutgoingLinks(id).then(links => {
              drawLinksFrom(id, links);
              window.__lastLinksState = { id, links };
              const b = new maplibregl.LngLatBounds();
              const from = idToItem.get(id); if (from) b.extend([from.lon, from.lat]);
              links.forEach(l => { const t = idToItem.get(l); if (t) b.extend([t.lon, t.lat]); });
              if (!b.isEmpty()) map.fitBounds(b, { padding: 80, duration: 650 });
            });
          });
        });
      }catch(err){
        document.getElementById('npTitle').textContent = noteId;
        document.getElementById('npMd').innerHTML = `<em style="color:#b91c1c;">Note introuvable (${err.message})</em>`;
        document.getElementById('notePanel').style.display = 'block';
      }
    }
    // rendre accessible globalement si besoin
    window.openNoteInPanel = openNoteInPanel;

    // Parse robuste : "YYYY-MM-DD", "DD/MM/YYYY", "DD-MM-YYYY" -> Date  
    function parseDateSmart(s){
      if (!s) return null;
      const str = String(s).trim();
      let m = str.match(/^(\d{4})-(\d{2})-(\d{2})$/);           // YYYY-MM-DD
      if (m) return new Date(+m[1], +m[2]-1, +m[3]);
      m = str.match(/^(\d{2})\/(\d{2})\/(\d{4})$/);             // DD/MM/YYYY
      if (m) return new Date(+m[3], +m[2]-1, +m[1]);
      m = str.match(/^(\d{2})-(\d{2})-(\d{4})$/);               // DD-MM-YYYY
      if (m) return new Date(+m[3], +m[2]-1, +m[1]);
      return null;
    }
    function formatDateByConfig(s){
      const d = parseDateSmart(s);
      if (!d) return s || '';
      return new Intl.DateTimeFormat('fr-FR', UI_CONFIG.header.dateFormat).format(d);
    }



  // Ouvre le RÉCAP + la NOTE COMPLÈTE dans le panneau (avec clamp du récap)
  async function openSummaryInPanel(noteId){
    const item   = idToItem.get(noteId);
    const $panel = document.getElementById('notePanel');
    const $title = document.getElementById('npTitle');
    const $place = document.getElementById('npPlace');
    const $date  = document.getElementById('npDate');
    const $recap = document.getElementById('npRecap');
    const $sum   = document.getElementById('npSummary');
    const $md    = document.getElementById('npMd');
    const $links = document.getElementById('npLinks');
    const $fit   = document.getElementById('npFit');
  
    // Sécurité
    if (!item) {
      $title.textContent = noteId;
      $place.textContent = '';
      $date.textContent  = '';
      $recap.innerHTML   = '';
      $sum.innerHTML     = '';
      $md.innerHTML      = '';
      $links.innerHTML   = '';
      $panel.style.display = 'block';
      return;
    }
  
    // ---- En-tête : titre + 📍 lieu (date sera remplie depuis .md)
    $title.textContent = item.title || noteId;
    $place.textContent = item.locationName || '';
    $date.textContent  = '';
  
    // ---- Récap (phrase courte) : d’abord data.json, puis éventuellement .md
    setRecapText(item.recap || '');
  
    // ---- Petit “summary” avant la note (facultatif)
    $sum.innerHTML = item.summary ? renderWikiLinksInline(item.summary) : '';
  
    // ---- NOTE COMPLÈTE (lecture .md) + date + recap (fallback)
    let links = [];
    try {
      const url = `${NOTE_RAW_BASE}/${encodeURIComponent(noteId)}.md`;
      const res = await fetch(url, { cache:'no-store' });
      if (res.ok) {
        const mdRaw = await res.text();
        const { meta, body } = parseAndStripFrontMatter(mdRaw);
  
        // date (front-matter)
        if (!$date.textContent && meta.date) {
          $date.textContent = formatDateByConfig(meta.date);
        }
        // recap depuis le .md si pas donné dans data.json
        if (!document.getElementById('npRecap').innerHTML && meta.recap) {
          setRecapText(meta.recap);
        }

  
        // Liens sortants (ids présents en [[...]])
        links = extractWikiLinks(mdRaw).filter(id => idToItem.has(id));
  
        // Rendu HTML de la note
        const htmlNote = marked.parse(transformWikiLinks(body));
        $md.innerHTML = htmlNote;
      } else {
        $md.innerHTML = `<em style="color:#888;">Note complète indisponible (HTTP ${res.status})</em>`;
      }
    } catch (err) {
      $md.innerHTML = `<em style="color:#888;">Note complète indisponible</em>`;
    }
  
    // ---- Section "Liens sortants"
    if (!links.length) {
      $links.innerHTML = `<div style="color:#888;">Aucun lien sortant</div>`;
    } else {
      $links.innerHTML = `
        <ul style="margin:0; padding-left:18px;">
          ${links.map(lid => {
            const it = idToItem.get(lid);
            const lbl = it?.title || lid;
            const commonTags = Array.isArray(item.tags) && Array.isArray(it?.tags)
              ? item.tags.filter(t => it.tags.includes(t))
              : [];
            const badge = commonTags.length
              ? ` <span style="color:#6b7280;">(${commonTags.join(', ')})</span>`
              : '';
            return `<li><a href="note.html?id=${encodeURIComponent(lid)}" class="internal-link">${lbl}</a>${badge}</li>`;
          }).join('')}
        </ul>
      `;
    }
  
    // ---- Affichage panneau
    $panel.style.display = 'block';
  
    // ---- Navigation interne dans le panneau
    $panel.querySelectorAll('a[href^="note.html?id="]').forEach(a => {
      a.classList.add('internal-link');
      a.addEventListener('click', (e) => {
        e.preventDefault();
        const href = a.getAttribute('href');
        const id = decodeURIComponent(href.split('id=')[1] || '');
        if (!id) return;
        openSummaryInPanel(id);
        setActiveMarker(id);
        getOutgoingLinks(id).then(lnk => {
          drawLinksFrom(id, lnk);
          window.__lastLinksState = { id, links: lnk };
          const b = new maplibregl.LngLatBounds();
          const from = idToItem.get(id); if (from) b.extend([from.lon, from.lat]);
          lnk.forEach(L => { const t = idToItem.get(L); if (t) b.extend([t.lon, t.lat]); });
          if (!b.isEmpty()) map.fitBounds(b, { padding: 80, duration: 650 });
        });
      });
    });
  
    // ---- Bouton “Voir les liés”
    if ($fit) {
      $fit.onclick = () => {
        const b = new maplibregl.LngLatBounds();
        const from = idToItem.get(noteId); if (from) b.extend([from.lon, from.lat]);
        links.forEach(lid => { const t = idToItem.get(lid); if (t) b.extend([t.lon, t.lat]); });
        if (!b.isEmpty()) map.fitBounds(b, { padding: 80, duration: 650 });
      };
    }

    // 🔎 Debug : vérifier les liens sortants trouvés
    console.log("Liens trouvés pour", noteId, ":", links);
    
    // ---- Traits & état mémorisé
    drawLinksFrom(noteId, links);
    window.__lastLinksState = { id: noteId, links };
  }




    // --- [[...]] cliquables dans les résumés (summary de data.json) ---
    function renderWikiLinksInline(text){
      if (!text) return '';
      return text.replace(/\[\[([^\]\|]+)(?:\|([^\]]+))?\]\]/g, (m, rawId, label) => {
        const id = String(rawId).trim();
        const txt = (label || id).trim();
        return `<a href="note.html?id=${encodeURIComponent(id)}" target="_blank" rel="noopener" class="internal-link">${txt}</a>`;
      });
    }

    // === Liens façon Obsidian entre notes ===
    function extractWikiLinks(mdText){
      const found = new Set();
      const re = /\[\[([^\]\|]+)(?:\|[^\]]+)?\]\]/g;
      let m;
      while ((m = re.exec(mdText)) !== null) {
        const id = m[1].trim();
        if (id) found.add(id);
      }
      return Array.from(found);
    }

    async function getOutgoingLinks(noteId){
      if (linksCache.has(noteId)) return linksCache.get(noteId);
      const url = `${NOTE_RAW_BASE}/${encodeURIComponent(noteId)}.md`;
      const res = await fetch(url, { cache:'no-store' });
      if (!res.ok) { linksCache.set(noteId, []); return []; }
      const md = await res.text();
      const ids = extractWikiLinks(md).filter(id => idToItem.has(id));
      linksCache.set(noteId, ids);
      return ids;
    }

    // === Couche des liens entre notes (lit le style depuis UI_CONFIG.links) ===
    function ensureLinksLayer() {
      // Attendre que le style soit prêt
      if (!map.isStyleLoaded?.() && !map.loaded?.()) {
        map.once('load', ensureLinksLayer);
        map.once('style.load', ensureLinksLayer);
        return;
      }
    
      // Source GeoJSON vide si inexistante
      if (!map.getSource('note-links')) {
        map.addSource('note-links', {
          type: 'geojson',
          data: { type: 'FeatureCollection', features: [] }
        });
      }
    
      // Lecture du style dans la config
      const L = (UI_CONFIG?.links) || {};
    
      // Optionnel : ajouter un "casing" (contour) sous la ligne pour le contraste
      const needCasing = (L.casingWidth || 0) > 0;
    
      // (Re)crée/actualise le layer de contour
      if (needCasing) {
        if (!map.getLayer('note-links-casing')) {
          map.addLayer({
            id: 'note-links-casing',
            type: 'line',
            source: 'note-links',
            layout: { 'line-cap': 'round', 'line-join': 'round' },
            paint: {
              'line-color': L.casingColor || '#ffffff',
              'line-width': (L.lineWidth || 3.5) + (L.casingWidth || 1.5),
              'line-opacity': L.lineOpacity ?? 0.95
            }
          });
        } else {
          // Met à jour les paint properties si le layer existe déjà
          map.setPaintProperty('note-links-casing', 'line-color',   L.casingColor || '#ffffff');
          map.setPaintProperty('note-links-casing', 'line-width',  (L.lineWidth || 3.5) + (L.casingWidth || 1.5));
          map.setPaintProperty('note-links-casing', 'line-opacity', L.lineOpacity ?? 0.95);
        }
      } else {
        // Pas de contour demandé => supprime le layer s’il existe
        if (map.getLayer('note-links-casing')) map.removeLayer('note-links-casing');
      }
    
      // (Re)crée/actualise le layer principal de ligne
      if (!map.getLayer('note-links-line')) {
        map.addLayer({
          id: 'note-links-line',
          type: 'line',
          source: 'note-links',
          layout: { 'line-cap': 'round', 'line-join': 'round' },
          paint: {
            'line-color':   L.lineColor   || '#ff0088',
            'line-width':   L.lineWidth   || 3.5,
            'line-opacity': L.lineOpacity ?? 0.95,
            ...(L.lineDasharray ? { 'line-dasharray': L.lineDasharray } : {})
          }
        }, needCasing ? undefined : undefined);
      } else {
        // Met à jour les paint properties si le layer existe déjà
        map.setPaintProperty('note-links-line', 'line-color',   L.lineColor   || '#ff0088');
        map.setPaintProperty('note-links-line', 'line-width',   L.lineWidth   || 3.5);
        map.setPaintProperty('note-links-line', 'line-opacity', L.lineOpacity ?? 0.95);
        if (L.lineDasharray) {
          map.setPaintProperty('note-links-line', 'line-dasharray', L.lineDasharray);
        } else {
          // retire l'éventuel dasharray si tu repasses à un trait plein
          try { map.setPaintProperty('note-links-line', 'line-dasharray', null); } catch {}
        }
      }
    
      // S'assurer que l'ordre est bon : casing en dessous de line
      try { map.moveLayer('note-links-casing'); } catch {}
      try { map.moveLayer('note-links-line'); } catch {}
    }
    
    // Trace les liens à partir d'une note
    function drawLinksFrom(noteId, linkedIds) {
      ensureLinksLayer();
      const src = map.getSource('note-links');
      if (!src) return;
    
      const from = idToItem.get(noteId);
      if (!from) {
        src.setData({ type: 'FeatureCollection', features: [] });
        return;
      }
    
      const features = (linkedIds || [])
        .map(id => {
          const to = idToItem.get(id);
          if (!to) return null;
          return {
            type: 'Feature',
            geometry: { type: 'LineString', coordinates: curveBetween(from, to) },
            properties: { from: noteId, to: id }
          };
        })
        .filter(Boolean);
    
      src.setData({ type: 'FeatureCollection', features });

      // S'assurer que nos traits sont au-dessus
      try { map.moveLayer('note-links-casing'); } catch {}
      try { map.moveLayer('note-links-line'); } catch {}
      try { map.moveLayer('note-links-arrows'); } catch {}
    }
    
    // Effacer les traits
    function clearLinks() {
      const src = map.getSource('note-links');
      if (src) src.setData({ type: 'FeatureCollection', features: [] });
    }

    // === Courbes entre points =====================================================
    // Bézier quadratique en coord. géo (approx locale), force = écart au milieu
    function bezierCurveCoords(from, to, strength = 0.25, steps = 64){
      const p0 = [from.lon, from.lat];
      const p2 = [to.lon,   to.lat];
    
      // milieu
      const mx = (p0[0] + p2[0]) / 2;
      const my = (p0[1] + p2[1]) / 2;
    
      // vecteur p0->p2
      const vx = p2[0] - p0[0];
      const vy = p2[1] - p0[1];
    
      // vecteur normal (perpendiculaire) pour bomber la courbe
      const nx = -vy;
      const ny =  vx;
    
      // normaliser
      const len = Math.sqrt(nx*nx + ny*ny) || 1;
      const ux = nx / len;
      const uy = ny / len;
    
      // amplitude en degrés (~, reste raisonnable pour petites distances)
      const amp = strength * Math.hypot(vx, vy);
      const cx  = mx + ux * amp;
      const cy  = my + uy * amp;
    
      const coords = [];
      for (let i = 0; i <= steps; i++){
        const t = i / steps;           // 0..1
        const it = 1 - t;
        // Quadratic Bézier : B(t) = (1−t)^2 P0 + 2(1−t)t C + t^2 P2
        const x = it*it*p0[0] + 2*it*t*cx + t*t*p2[0];
        const y = it*it*p0[1] + 2*it*t*cy + t*t*p2[1];
        coords.push([x, y]);
      }
      return coords;
    }
    
    // Arc géodésique (grand cercle) via Turf (si dispo)
    function geodesicCoords(from, to, steps = 64){
      if (!(window.turf && turf.greatCircle)) {
        // fallback : simple segment si Turf n'est pas chargé
        return [[from.lon, from.lat],[to.lon, to.lat]];
      }
      const fc = turf.greatCircle(
        [from.lon, from.lat],
        [to.lon, to.lat],
        { npoints: Math.max(2, steps), properties: {} }
      );
      return fc.geometry.coordinates;
    }
    
    // Wrapper selon UI_CONFIG
    function curveBetween(from, to){
      const L = (UI_CONFIG && UI_CONFIG.links) || {};
      const style  = L.curveStyle || "bezier";
      const steps  = L.curveSteps || 64;
      if (style === "geodesic") return geodesicCoords(from, to, steps);
      const strength = L.curveStrength ?? 0.25;
      return bezierCurveCoords(from, to, strength, steps);
    }

    // === Données & Marqueurs & Filtres ===
    let allData = [];      // toutes les entrées JSON (chargées une fois)
    let allMarkers = [];   // { item, marker }
    let allTags = new Set();

    // Gère l'état "marqueur actif"
    function setActiveMarker(noteId){
      // Enlever l'ancien actif
      if (window.__activeMarkerEl){
        window.__activeMarkerEl.classList.remove('marker--active');
        window.__activeMarkerEl.style.zIndex = '';
      }
      // Activer le nouveau
      const it = idToItem.get(noteId);
      const el = it && it.__el;
      if (el){
        el.classList.add('marker--active');
        el.style.zIndex = '10';
        window.__activeMarkerEl = el;
      } else {
        window.__activeMarkerEl = null;
      }
    }
    
    async function addMarkersFromJSON() {
      // charge data.json une seule fois
      if (allData.length === 0) {
        try {
          const res = await fetch('data.json', { cache: 'no-store' });
          allData = await res.json();
        } catch (e) {
          console.error('Erreur chargement data.json', e);
          return;
        }
      }

      // 3.3 — index rapide id -> item (sert aux liens entre notes)
      idToItem.clear();
      allData.forEach(it => { if (it && it.id) idToItem.set(it.id, it); });

      // nettoie anciens marqueurs
      allMarkers.forEach(({marker}) => marker.remove());
      allMarkers = [];
      allTags.clear();

      // crée les marqueurs
      allData.forEach(item => {
      // ➕ collecte les tags pour les filtres
        if (Array.isArray(item.tags)) {
          item.tags.forEach(t => { if (t && String(t).trim()) allTags.add(String(t).trim()); });
        }
        if (typeof item.lon === 'number' && typeof item.lat === 'number') {
          // STYLE du marqueur (rouge + bordure rouge foncé)
          const el = document.createElement('div');
          el.style.width = '14px';
          el.style.height = '14px';
          el.style.borderRadius = '50%';
          el.style.background = 'red';             // centre
          el.style.border = '2px solid darkred';   // contour
          el.style.boxShadow = '0 1px 6px rgba(0,0,0,0.3)';
          el.title = item.title || '';

          el.dataset.id = item.id;
          item.__el = el;

          const marker = new maplibregl.Marker({ element: el })
            .setLngLat([item.lon, item.lat])
            .addTo(map);

          // Clic sur le marqueur => ouvre le panneau + trace (et empêche l’effacement global)
          el.addEventListener('click', async (ev) => {
            ev.preventDefault();
            ev.stopPropagation();
          
            // Empêche l’handler global 'map.on("click")' d'effacer les traits
            window.__justClickedMarker = true;
            setTimeout(() => { window.__justClickedMarker = false; }, 0);
          
            // Ouvre le panneau résumé
            await openSummaryInPanel(item.id);
            setActiveMarker(item.id);
          
            // Calcule et trace les liens
            const links = await getOutgoingLinks(item.id);
            drawLinksFrom(item.id, links);
            window.__lastLinksState = { id: item.id, links };
          });
          allMarkers.push({ item, marker });
        }
      });

      // construit la liste de tags (si des tags existent)
      buildTagCheckboxes();
    }

    function buildTagCheckboxes(){
      const box = document.getElementById('tagsBox');
      if (!box) return;
      box.innerHTML = '';
      if (allTags.size === 0) {
        box.innerHTML = '<div style="color:#777; font-size:13px;">Aucun tag détecté</div>';
        return;
      }
      Array.from(allTags).sort((a,b)=>a.localeCompare(b)).forEach(tag => {
        const label = document.createElement('label');
        label.className = 'tag';
        const cb = document.createElement('input');
        cb.type = 'checkbox';
        cb.name = 'tag';
        cb.value = tag;
        const txt = document.createElement('span');
        txt.textContent = tag;
        label.appendChild(cb);
        label.appendChild(txt);
        box.appendChild(label);
      });
    }

    function applyFilters(){
      const q = (document.getElementById('filterQuery')?.value || '').toLowerCase().trim();
      const selected = Array.from(document.querySelectorAll('input[name="tag"]:checked')).map(i => i.value);

      // 🔽 Pays sélectionnés (multiselect)
      const sel = document.getElementById('filterCountry');
      const selectedCountries = sel ? Array.from(sel.selectedOptions).map(o => o.value) : [];

      allMarkers.forEach(({ item, marker }) => {
        let visible = true;

        // Filtre texte
        if (q) {
          const hay = [item.title||'', item.locationName||'', item.summary||''].join(' ').toLowerCase();
          visible = hay.includes(q);
        }

        // Filtre tags (ET logique)
        if (visible && selected.length) {
          const itags = Array.isArray(item.tags) ? item.tags.map(String) : [];
          visible = selected.every(t => itags.includes(t));
        }

        // 🔽 Filtre pays (OU logique entre pays sélectionnés)
        if (visible && selectedCountries.length) {
          const lon = item.lon, lat = item.lat;
          visible = selectedCountries.some(countryName => {
            const bbox = countriesBbox[countryName];
            return bbox ? pointInBbox(lon, lat, bbox) : false;
          });
        }

        marker.getElement().style.display = visible ? '' : 'none';
      });
    }

    function resetFilters(){
      // Réinitialiser recherche
      const q = document.getElementById('filterQuery');
      if (q) q.value = '';

      // Réinitialiser tags
      document.querySelectorAll('input[name="tag"]:checked').forEach(cb => cb.checked = false);

      // Réinitialiser pays
      const sel = document.getElementById('filterCountry');
      if (sel) Array.from(sel.options).forEach(o => o.selected = false);

      // Réafficher tous les marqueurs
      allMarkers.forEach(({marker}) => marker.getElement().style.display = '');

      // Fermer le panneau
      const panel = document.getElementById('filtersPanel');
      if (panel) panel.style.display = 'none';

      // 🔽 Recentrer sur l’Europe (constants)
      map.easeTo({ center: EUROPE_CENTER, zoom: DEFAULT_ZOOM, duration: 600 });
    }

    function zoomToVisibleMarkers(){
      const visibles = allMarkers.filter(({marker}) => marker.getElement().style.display !== 'none');
      if (visibles.length === 0) return;

      if (visibles.length === 1) {
        const [lon, lat] = visibles[0].marker.getLngLat().toArray();
        map.easeTo({ center: [lon, lat], zoom: 8, duration: 600 });
        return;
      }

      const bounds = new maplibregl.LngLatBounds();
      visibles.forEach(({marker}) => bounds.extend(marker.getLngLat()));
      map.fitBounds(bounds, { padding: 60, duration: 700 });
    }

    // Branche les boutons du panneau filtres
    document.getElementById('applyFilters')?.addEventListener('click', () => {
      applyFilters();
      zoomToVisibleMarkers(); // 🔎 recadre sur les résultats filtrés
      document.getElementById('filtersPanel').style.display = 'none'; // ferme le panneau
    });
    document.getElementById('resetFilters')?.addEventListener('click', resetFilters);

    // Pays: tout sélectionner / tout désélectionner
    document.getElementById('selectAllCountries')?.addEventListener('click', () => {
      const sel = document.getElementById('filterCountry');
      if (!sel) return;
      Array.from(sel.options).forEach(o => o.selected = true);
    });
    document.getElementById('clearAllCountries')?.addEventListener('click', () => {
      const sel = document.getElementById('filterCountry');
      if (!sel) return;
      Array.from(sel.options).forEach(o => o.selected = false);
    });

    // Effacer les traits seulement si on clique vraiment sur la carte (pas un marqueur / pas l'UI)
    map.on('click', (e) => {
      // si on vient de cliquer un marqueur, ne rien faire
      if (window.__justClickedMarker) return;
    
      // si le clic provient d’un marqueur (DOM), ne rien faire
      const path = e.originalEvent?.composedPath?.() || [];
      const onMarker = path.some(n => n?.classList?.contains?.('maplibregl-marker'));
      if (onMarker) return;
    
      // sinon, on peut nettoyer
      clearLinks();
    });

  // === Fermeture du panneau (✖) ===
  (function setupNotePanelClose(){
    const btn = document.getElementById('npClose');
    if (!btn) return;

    const closePanel = () => {
      const panel = document.getElementById('notePanel');
      if (panel) panel.style.display = 'none';
    
      // Efface les traits [[liens]] s'ils sont affichés
      if (typeof clearLinks === 'function') clearLinks();
    
      // Désactive le marqueur actif (revient à la couleur rouge par défaut)
      if (window.__activeMarkerEl) {
        window.__activeMarkerEl.classList.remove('marker--active');
        window.__activeMarkerEl.style.zIndex = '';
        window.__activeMarkerEl = null;
      }
    };

    btn.addEventListener('click', closePanel);

    // Bonus utile : fermer avec Échap
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') closePanel();
    });
  })();

    // === Toggle panneau "Map views" (haut-gauche)
    (function setupMapPanelToggle(){
      const panel  = document.getElementById('mapPanel');
      const toggle = document.getElementById('mapPanelToggle');
      const close  = document.getElementById('mapPanelClose');
    
      if (!panel || !toggle || !close) return;
    
      const show = () => {
        panel.classList.remove('panel-hidden');
        toggle.setAttribute('aria-expanded','true');
      };
      const hide = () => {
        panel.classList.add('panel-hidden');
        toggle.setAttribute('aria-expanded','false');
      };
    
      toggle.addEventListener('click', () => {
        const opened = toggle.getAttribute('aria-expanded') === 'true';
        opened ? hide() : show();
      });
      close.addEventListener('click', hide);
    
      // Option: ESC ferme le panneau
      document.addEventListener('keydown', (e) => { if (e.key === 'Escape') hide(); });
    
      // État initial: fermé (bouton seul visible)
      hide();
    })();
    
    loadCountries();
    applyUIConfig();
    
  </script>
</body>
</html>
